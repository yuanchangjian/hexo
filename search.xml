<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFS和DFS</title>
    <url>/2020/05/19/BFS%E5%92%8CDFS/</url>
    <content><![CDATA[<p>下面我们通过一个二叉树层序遍历的题目来分析一下BFS和DFS方法的区别。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">例题</a></h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>左边是BFS，按照层进行搜索；右边是DFS，先一路走到底，当无路可走则回溯上来，走其他路。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519101431.png" alt="image-20200519101430606"></p>
<h1 id="BFS（breadth-First-Search）广度优先搜索"><a href="#BFS（breadth-First-Search）广度优先搜索" class="headerlink" title="BFS（breadth First Search）广度优先搜索"></a>BFS（breadth First Search）广度优先搜索</h1><p>BFS总共有两个通用模板。</p>
<p>1.如果不需要确定当前遍历到了哪一层，BFS模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while queue 不空：</span><br><span class="line">    cur &#x3D; queue.pop()</span><br><span class="line">    for 节点 in cur的所有相邻节点：</span><br><span class="line">        if 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></table></figure>

<p>2.如果要确定当前遍历到了哪一层，BFS模板如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">level &#x3D; 0</span><br><span class="line">while queue 不空：</span><br><span class="line">    size &#x3D; queue.size()</span><br><span class="line">    while (size --) &#123;</span><br><span class="line">        cur &#x3D; queue.pop()</span><br><span class="line">        for 节点 in cur的所有相邻节点：</span><br><span class="line">            if 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure>

<p>本题要求二叉树的层次遍历，所以同一层的节点应该放在一起，故使用模板二。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var levelOrder &#x3D; function(root) &#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    if (!root) return result;</span><br><span class="line">    var queue &#x3D; [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    while (queue.length !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        var length &#x3D; queue.length;</span><br><span class="line">        result.push([]);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            var treeNode &#x3D; queue.shift();</span><br><span class="line">            result[result.length - 1].push(treeNode.val);</span><br><span class="line">            if (treeNode.left) queue.push(treeNode.left);</span><br><span class="line">            if (treeNode.right) queue.push(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现过程如下所示，我们先将根节点放到队列中。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519110047.png" alt="image-20200519110046014"></p>
<p>首先拿出根节点，如果左子树/右子树不为空，就将他们放入队列中。第一遍处理完后，根节点已经从队列中拿走了，而根节点的两个孩子已放入队列中了，现在队列中就有两个节点 <code>2</code> 和 <code>5</code>。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519110134.png" alt="image-20200519110133339"></p>
<p>第二次处理，会将 <code>2</code> 和 <code>5</code> 这两个节点从队列中拿走，然后再将 2 和 5 的子节点放入队列中，现在队列中就有三个节点 <code>3</code>，<code>4</code>，<code>6</code>。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519110207.png" alt="image-20200519110206085"></p>
<p>我们把每层遍历到的节点都放入到一个结果集中，最后返回这个结果集就可以了。</p>
<h1 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a>DFS（Deep First Search）深度优先搜索</h1><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200725172214.gif" alt="1"></p>
<p> DFS 不是按照层次遍历的。为了让递归的过程中同一层的节点放到同一个列表中，在递归时要记录每个节点的深度 level。递归到新节点要把该节点放入 level 对应列表的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var levelOrder &#x3D; function(root) &#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    if (!root) return result;</span><br><span class="line"></span><br><span class="line">    var dfs &#x3D; function(node, level) &#123;</span><br><span class="line">        if (result.length - 1 &lt; level) &#123;</span><br><span class="line">            result.push([]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result[level - 1].push(node.val);</span><br><span class="line">        if (node.left) dfs(node.left, level + 1);</span><br><span class="line">        if (node.right) dfs(node.right, level + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root, 0);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="数据结构上的运用"><a href="#数据结构上的运用" class="headerlink" title="数据结构上的运用"></a>数据结构上的运用</h2><p>DFS用递归的形式，用到了栈结构，先进后出。</p>
<p>BFS选取状态用队列的形式，先进先出。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>思想上来说这两种方法都是穷竭列举所有的情况。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树层序遍历（leetcode）</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/" target="_blank" rel="noopener">套模板！BFS 和 DFS 都可以解决</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/" target="_blank" rel="noopener">BFS 的使用场景总结：层序遍历、最短路径问题</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/24986203" target="_blank" rel="noopener">搜索思想——DFS &amp; BFS（基础基础篇）</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客系列：（三）Typora+PicGo实现图片上传功能</title>
    <url>/2020/05/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89Typora-PicGo%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>编写markdown时经常会有插入图片的需求，而粘贴的图片的地址为本地地址，部署时是无法查看的。办法总比问题多，下面教大家使用Typora+PicGo+GitHub图床给markdown愉快的添加图片。</p>
<a id="more"></a>



<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>自行下载安装如下软件：</p>
<ul>
<li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></li>
<li><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a></li>
</ul>
<h2 id="Github图床"><a href="#Github图床" class="headerlink" title="Github图床"></a>Github图床</h2><ul>
<li>新建repository，命名为<code>cloudImage</code></li>
<li>添加访问token，复制并保存token（只会出现一次）</li>
</ul>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518162329.png" alt="image-20200518162328069"></p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518162424.png" alt="image-20200518162420210"></p>
<p>​    <img src="https://yuanchangjian.github.io/cloudImage/images/20200518162122.png" alt="image-20200518162120925"></p>
<p>​    <img src="https://yuanchangjian.github.io/cloudImage/images/20200518162215.png" alt="image-20200518162213723"></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置typora"><a href="#配置typora" class="headerlink" title="配置typora"></a>配置typora</h2><p>打开typora，选择左上角<code>文件</code>，选择<code>偏好设置</code>，配置成如下所示：</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518160024.png" alt="image-20200518155153969"></p>
<h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><h3 id="图床设置"><a href="#图床设置" class="headerlink" title="图床设置"></a>图床设置</h3><p>根据上述新建的GitHub图床进行配置（我这里在仓库内创建了一个<code>images</code>目录存储图片）。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518162932.png" alt="image-20200518162929836"></p>
<h3 id="开启时间戳重命名"><a href="#开启时间戳重命名" class="headerlink" title="开启时间戳重命名"></a>开启时间戳重命名</h3><p>防止GitHub重名上传失败。</p>
<p> <img src="https://yuanchangjian.github.io/cloudImage/images/20200518163356.png" alt="image-20200518163355105"></p>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p>将本地图片放入Typora时，会出现上传地图选项，点击上传图片即可。这里我演示一下图片地址的变化：</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518164244.png" alt="image-20200518164240350"></p>
<p>上传后图片地址：</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518164336.png" alt="image-20200518164334296"></p>
]]></content>
      <categories>
        <category>Hexo搭建博客系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客系列：（二）自定义样式优化主题</title>
    <url>/2020/05/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本教程是我对Next主题的一些自定义样式修改，主要通过两种方式：修改<code>主题配置文件</code>和自定义样式。</p>
<a id="more"></a>

<h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><h3 id="隐藏文章更新日期"><a href="#隐藏文章更新日期" class="headerlink" title="隐藏文章更新日期"></a>隐藏文章更新日期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at:</span><br><span class="line">    enable: false</span><br><span class="line">    another_day: true</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure>

<h3 id="友情链接行内布局"><a href="#友情链接行内布局" class="headerlink" title="友情链接行内布局"></a>友情链接行内布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: Links</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: inline</span><br></pre></td></tr></table></figure>

<h3 id="footer图标颜色"><a href="#footer图标颜色" class="headerlink" title="footer图标颜色"></a>footer图标颜色</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  ...</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https:&#x2F;&#x2F;fontawesome.com&#x2F;icons</span><br><span class="line">    name: fa fa-heart</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#000000&quot;&#39;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>



<h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><p>在主题目录的<code>/source/css</code>目录下新建<code>_custom.styl</code>文件。内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 文章目录显示多级标题,文章展示所有二级菜单</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;显示一级标题下的子标题</span><br><span class="line">.post-toc .nav .nav-level-1 &gt; .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示二级标题下的子标题</span><br><span class="line">&#x2F;*.post-toc .nav .nav-level-2 &gt; .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;&#x2F;*</span><br><span class="line">&#x2F;&#x2F;显示三级标题下的子标题</span><br><span class="line">&#x2F;*.post-toc .nav .nav-level-3 &gt; .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* 导航栏菜单右对齐</span><br><span class="line">*&#x2F;</span><br><span class="line">.menu &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Hexo搭建博客系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>editorconfig规范代码</title>
    <url>/2020/06/11/editorconfig%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>EditorConfig 可以帮助开发者在不同的编辑器和 IDE 之间定义和维护一致的代码风格。EditorConfig 包含一个用于定义代码格式的文件和一批编辑器插件，这些插件可以让编辑器读取配置文件并依此格式化代码。</p>
<a id="more"></a>



<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="indent-style"><a href="#indent-style" class="headerlink" title="indent_style"></a>indent_style</h3><p>缩进方式，可选值：</p>
<ul>
<li><code>tab</code></li>
<li><code>space</code></li>
</ul>
<h3 id="indent-size"><a href="#indent-size" class="headerlink" title="indent_size"></a>indent_size</h3><p>缩进长度，可选值：</p>
<ul>
<li>整数</li>
<li><code>tab</code></li>
</ul>
<h3 id="end-of-line"><a href="#end-of-line" class="headerlink" title="end_of_line"></a>end_of_line</h3><p>换行符，可选值：</p>
<ul>
<li><code>lf</code></li>
<li><code>crlf</code></li>
<li><code>cr</code></li>
</ul>
<h3 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h3><p>文件字符编码，可选值：</p>
<ul>
<li><code>latin1</code></li>
<li><code>utf-8</code></li>
<li><code>utf-16be</code></li>
<li><code>utf-16le</code></li>
<li><code>utf-8-bom</code></li>
</ul>
<h3 id="trim-trailing-whitespace"><a href="#trim-trailing-whitespace" class="headerlink" title="trim_trailing_whitespace"></a>trim_trailing_whitespace</h3><p>是否将行尾空格自动删除，可选值：</p>
<ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h3 id="insert-final-newline"><a href="#insert-final-newline" class="headerlink" title="insert_final_newline"></a>insert_final_newline</h3><p>是否使文件以一个空白行结尾，可选值：</p>
<ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><p>表明是最顶层的配置文件，发现设为 <code>true</code> 时，才会停止查找<code>.editorconfig</code> 文件。</p>
<h2 id="个人常用配置"><a href="#个人常用配置" class="headerlink" title="个人常用配置"></a>个人常用配置</h2><p>在项目根目录新建<code>.editorconfig</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># https:&#x2F;&#x2F;editorconfig.org</span><br><span class="line"></span><br><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 4</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">insert_final_newline &#x3D; false</span><br><span class="line">trim_trailing_whitespace &#x3D; false</span><br></pre></td></tr></table></figure>



<h1 id="编辑器启动EditorConfig插件"><a href="#编辑器启动EditorConfig插件" class="headerlink" title="编辑器启动EditorConfig插件"></a>编辑器启动EditorConfig插件</h1><ul>
<li><p><a href="https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig" target="_blank" rel="noopener">EditorConfig for VS Code</a></p>
</li>
<li><p>webstorm</p>
<p>  File &gt; settings &gt; Editor &gt; Code Style &gt; Enable EditorConfig support</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>editorconfig</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法查找</title>
    <url>/2020/05/20/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>下面我们通过一个二分法查找的题目来了解一下二分法的特征。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">例题</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>如果该题目暴力解决的话需要 O(n)的时间复杂度，但是如果二分的话则可以降低到 O(logn)的时间复杂度。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200520181043.png" alt="image-20200520181042129"></p>
<p>二分法模板如下所示，特殊注意一下边界问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int left &#x3D; 0, right &#x3D; nums.length - 1; &#x2F;&#x2F; 注意</span><br><span class="line">        while(left &lt;&#x3D; right) &#123; &#x2F;&#x2F; 注意</span><br><span class="line">            int mid &#x3D; (left + right) &#x2F; 2; &#x2F;&#x2F; 注意</span><br><span class="line">            if(nums[mid] &#x3D;&#x3D; target) &#123; &#x2F;&#x2F; 注意</span><br><span class="line">                &#x2F;&#x2F; 相关逻辑</span><br><span class="line">            &#125; else if(nums[mid] &lt; target) &#123;</span><br><span class="line">                left &#x3D; mid + 1; &#x2F;&#x2F; 注意</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right &#x3D; mid - 1; &#x2F;&#x2F; 注意</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 相关返回值</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int left &#x3D; 0, right &#x3D; nums.length - 1;</span><br><span class="line">        while(left &lt;&#x3D; right) &#123;</span><br><span class="line">            int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">            if(nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if(nums[mid] &lt; target) &#123;</span><br><span class="line">                left &#x3D; mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二分法查找是一种将有序数据查找特定元素的搜索方法。它的思想如下所示：</p>
<ol>
<li>将数组元素的中间位置开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。</li>
<li>如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。</li>
<li>如果某一步数组为空，则表示找不到目标元素。</li>
</ol>
<div class="note danger">
            <p>二分法思想简单，但索引很容易弄错，可以按照下面的同一思想编写：</p><ul><li>初始化边界时，左右边界为数组的索引边界，即left为0；right为数组长度-1</li><li>移动边界时，我们根据待搜索区别分别移动至中间的左边和右边，即left = mid -1和right = mid - 1;</li></ul>
          </div>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">用「排除法」（减治思想）写二分查找问题、与其它二分查找模板的比较</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/05/28/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。它包括<strong>抽象主题，委托类，代理类</strong>三个核心角色。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200608115447.png" alt="image-20200528210755896"></p>
<p><strong>Subject</strong></p>
<p>抽象主题</p>
<p><strong>Proxy</strong><br>代理类</p>
<p><strong>RealSubject</strong></p>
<p>委托类</p>
<a id="more"></a>

<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;This is real doSomeThing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProxySubject implements Subject &#123;</span><br><span class="line">    private Subject mSubject;</span><br><span class="line">    &#x2F;&#x2F; 代理类持有委托类的引用</span><br><span class="line">    public ProxySubject(Subject realSubject) &#123;</span><br><span class="line">        mSubject &#x3D; realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    	&#x2F;&#x2F; ...在之前做点什么</span><br><span class="line">        mSubject.doSomething();</span><br><span class="line">        &#x2F;&#x2F; ...在之后做点什么</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建委托类</span><br><span class="line">        Subject mRealSubject &#x3D; new RealSubject();</span><br><span class="line">        &#x2F;&#x2F; 创建代理类</span><br><span class="line">        ProxySubject mProxy &#x3D; new ProxySubject(mRealSubject);</span><br><span class="line">        &#x2F;&#x2F; 由代理类去做具体的操作</span><br><span class="line">        mProxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理模式使委托类只需关注内部代码逻辑，减少了这些和委托类不相关的程序控制的代码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-代理模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2020/05/28/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>桥接模式</strong>是把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200528171528.png" alt="image-20200528152550208"></p>
<p><strong>Abstraction</strong></p>
<p>定义抽象的接口，该接口包含实现具体行为、具体特征的Implementor接口</p>
<p><strong>Refined Abstraction</strong></p>
<p>抽象接口Abstraction的子类，依旧是一个抽象的事物名</p>
<p><strong>Implementor</strong></p>
<p>定义具体行为、具体特征的应用接口</p>
<p><strong>ConcreteImplementor</strong></p>
<p>实现Implementor接口</p>
<a id="more"></a>

<h1 id="示例：拼装对象"><a href="#示例：拼装对象" class="headerlink" title="示例：拼装对象"></a>示例：拼装对象</h1><p>我们先来看一个示例，假设我们有如下的描述：</p>
<ul>
<li>四个物体：木头桌子、木头椅子、塑料桌子、塑料椅子</li>
<li>五个属性：燃点、密度、价格、体积、重量（由密度和体积属性得出）</li>
</ul>
<p>那么，我们怎么用面向对象的方式来设计我们的类呢？参看下图：</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200528171535.png" alt="image-20200528154626071"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Implementor：材料类</span><br><span class="line">class Material &#123;</span><br><span class="line">    &#x2F;&#x2F; 密度</span><br><span class="line">    private double density;</span><br><span class="line">    &#x2F;&#x2F; 燃点</span><br><span class="line">    private double burning;</span><br><span class="line">    </span><br><span class="line">    public Material(double density, double burning) &#123; </span><br><span class="line">        this.density &#x3D; density; </span><br><span class="line">        this.burning &#x3D; burning; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">	public double getDensity () &#123;</span><br><span class="line">        return this.density;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double getBurningPoint () &#123;</span><br><span class="line">        return this.burning;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ConcreteImplementor: 木头</span><br><span class="line">class Wood extends Material &#123;</span><br><span class="line">    public Wood(double density, double burning) &#123; </span><br><span class="line">        super(density, burning); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ConcreteImplementor: 塑料</span><br><span class="line">class Plastic extends Material &#123;</span><br><span class="line">    public Plastic(double density, double burning) &#123; </span><br><span class="line">        super(density, burning); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Abstraction：家具类</span><br><span class="line">class Furnlture &#123;</span><br><span class="line">    &#x2F;&#x2F; 体积</span><br><span class="line">    private double volume;</span><br><span class="line">    &#x2F;&#x2F; 价格</span><br><span class="line">    private double price;</span><br><span class="line">    &#x2F;&#x2F; 材料</span><br><span class="line">    private Material material;</span><br><span class="line">    </span><br><span class="line">    public Furnlture(double volume, double price, Material material) &#123;</span><br><span class="line">        this.density &#x3D; density;</span><br><span class="line">        this.burning &#x3D; burning;         </span><br><span class="line">        this.material &#x3D; material;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取重量</span><br><span class="line">    public double getWeight () &#123;</span><br><span class="line">        return this.volume * this.material.getDensity();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Refined Abstraction: 桌子</span><br><span class="line">class Table extends Furnlture &#123;</span><br><span class="line">    public Table(double volume, double price, Material material) &#123; </span><br><span class="line">        super(volume, price, material); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Refined Abstraction: 桌子</span><br><span class="line">class Desk extends Furnlture &#123;</span><br><span class="line">    public Desk(double volume, double price, Material material) &#123; </span><br><span class="line">        super(volume, price, material); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Client</span><br><span class="line">class BridgePattern &#123;</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       &#x2F;&#x2F; 木头桌子</span><br><span class="line">       Furnlture table &#x3D; new Table(1, 2, new Wood(1, 2));</span><br><span class="line">       table.getWeight();&#x2F;&#x2F; 获取木头桌子重量</span><br><span class="line">       &#x2F;&#x2F; 塑料</span><br><span class="line">       Furnlture desk &#x3D; new Desk(1, 2, new Plastic(1, 2));</span><br><span class="line">       table.getWeight();&#x2F;&#x2F; 获取塑料椅子重量</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设计的优点显而易见，它能和现实世界相对应起来，而且，材料类是可以重用的。因此当一个问题有多个维度且每个维度可独立扩展时，使用桥接模式可以将具体特征分离开。如上述例子，若不采用桥接模式，我们需要多继承或将多个属性加入<strong>Abstraction</strong>中，若加入属性存在功能扩展就增加了<strong>Abstraction</strong>类的复杂度。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>桥接模式表现了面向对象的拼装数据的另一个精髓——喜欢组合，而不是继承</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">桥接模式-维基百科</a></p>
</li>
<li><p><a href="https://time.geekbang.org/column/article/2729" target="_blank" rel="noopener">编程范式游记（6）- 面向对象编程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/05/28/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。</p>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>策略模式把对象本身和运算规则区分开来，因此我们整个模式也分为三个部分：</p>
<ul>
<li>环境类(Context):用来操作策略的上下文环境</li>
<li>抽象策略类(Strategy):策略的抽象</li>
<li>具体的策略实现(ConcreteStrategyA、ConcreteStrategyB)</li>
</ul>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200528175354.png" alt="image-20200528175353400"></p>
<a id="more"></a>

<h1 id="示例：拼装功能"><a href="#示例：拼装功能" class="headerlink" title="示例：拼装功能"></a>示例：拼装功能</h1><p>举一个例子，处理电商系统中的订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Strategy：计费策略</span><br><span class="line">interface BillingStrategy &#123;</span><br><span class="line">    public double GetActPrice(double rawPrice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ConcreteStrategyA：正常计费</span><br><span class="line">&#x2F;&#x2F; Normal billing strategy (unchanged price)</span><br><span class="line">class NormalStrategy implements BillingStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double GetActPrice(double rawPrice) &#123;</span><br><span class="line">        return rawPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ConcreteStrategyB：打折(5折)收费</span><br><span class="line">&#x2F;&#x2F; Strategy for Happy hour (50% discount)</span><br><span class="line">class HappyHourStrategy implements BillingStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double GetActPrice(double rawPrice) &#123;</span><br><span class="line">        return rawPrice * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class OrderItem &#123;</span><br><span class="line">    &#x2F;&#x2F; 名称</span><br><span class="line">    public String Name; </span><br><span class="line">    &#x2F;&#x2F; 价格</span><br><span class="line">    public double Price; </span><br><span class="line">    &#x2F;&#x2F; 数量</span><br><span class="line">    public int Quantity;</span><br><span class="line">    &#x2F;&#x2F; 计费策略</span><br><span class="line">    public BillingStrategy Strategy; </span><br><span class="line">    </span><br><span class="line">    public OrderItem(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class="line">        this.Name &#x3D; name;</span><br><span class="line">        this.Price &#x3D; price;</span><br><span class="line">        this.Quantity &#x3D; quantity;</span><br><span class="line">        this.Strategy &#x3D; strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Context： 订单处理上下文环境</span><br><span class="line">class Order &#123;</span><br><span class="line">    &#x2F;&#x2F; 订单列表</span><br><span class="line">    private List&lt;OrderItem&gt; orderItems &#x3D; new ArrayList&lt;OrderItem&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加订单项</span><br><span class="line">    public void Add(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class="line">        orderItems.add(new OrderItem(name, price, quantity, strategy));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Payment of bill</span><br><span class="line">    public void PayBill() &#123;</span><br><span class="line">        double sum &#x3D; 0;</span><br><span class="line">        for (OrderItem item : orderItems) &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据订单的不同策略计算</span><br><span class="line">            double actPrice &#x3D; item.Strategy.GetActPrice(item.price * item.quantity);</span><br><span class="line">            sum +&#x3D; actPrice;</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;%s -- %f(%d) - %f&quot;, </span><br><span class="line">                item.name, item.price, item.quantity, actPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Total due: &quot; + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Client</span><br><span class="line">class StrategyPattern &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Order order &#x3D; new Order();</span><br><span class="line">        &#x2F;&#x2F; 添加正常商品</span><br><span class="line">        order.add(new OrderItem(&quot;商品&quot;, 10, 10, new NormalStrategy()));</span><br><span class="line">        &#x2F;&#x2F; 添加打折商品</span><br><span class="line">        order.add(new OrderItem(&quot;商品&quot;, 10, 10, new HappyHourStrategy()));</span><br><span class="line">        &#x2F;&#x2F; 计算总价</span><br><span class="line">        order.PayBill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>策略模式是一个比较容易理解和使用的设计模式，它将同一行为的每个不同实现都封单独装成一个类。这样便于将对象本身和运算规则分离，同时也便于运算规则的横向扩展。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科-策略模式</a></p>
</li>
<li><p><a href="https://time.geekbang.org/column/article/2729" target="_blank" rel="noopener">编程范式游记（6）- 面向对象编程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>语义化版本控制规范（SemVer）</title>
    <url>/2020/05/19/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%A7%84%E8%8C%83%EF%BC%88SemVer%EF%BC%89/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>semver</code> 是 <a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本（Semantic Versioning）规范</a> 的一个实现，目前是由 <code>npm</code> 的团队维护，实现了版本和版本范围的解析、计算、比较。下面列举一个<code>npm</code>下<code>vue</code>的版本历史。</p>
<a id="more"></a>

<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519192502.png" alt="image-20200519181754033"></p>
<h1 id="版本格式"><a href="#版本格式" class="headerlink" title="版本格式"></a>版本格式</h1><ol>
<li>主版本号：当你做了不兼容的 API 修改。（如：V2.6.11 -&gt; V3.0.0-alpha.0）</li>
<li>次版本号：当你做了向下兼容的功能性新增。（如：V2.5.22 -&gt; V2.6.0）</li>
<li>修订号：当你做了向下兼容的问题修正。（如：V2.6.10 -&gt; V2.6.11）</li>
</ol>
<h1 id="先行版本"><a href="#先行版本" class="headerlink" title="先行版本"></a>先行版本</h1><p>先行版本表示这个版本并非稳定，可以作为发布正式版之前的版本，格式是在修订版本号后面加上一个连接号<code>（-）</code>，再加上一连串以点（.）分割的标识符，标识符可以由英文、数字和连接号（[0-9A-Za-z-]）组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.6.0-beta.1</span><br><span class="line">3.0.0-alpha.0</span><br><span class="line">1.0.0-0.3.7</span><br><span class="line">1.0.0-x.7.z.92</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以下是一些常见的先行版本号名称：</p>
<ul>
<li>alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</li>
<li>beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li>
<li>rc：（Release　Candidate)  系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</li>
</ul>
<h1 id="版本编译元数据（可选）"><a href="#版本编译元数据（可选）" class="headerlink" title="版本编译元数据（可选）"></a>版本编译元数据（可选）</h1><p>版本编译元数据可以被标注在修订版或先行版本号之后，先加上一个<code>加号</code>再加上一连串以句点分隔的标识符来修饰。当判断版本的优先层级时，版本编译元数据可被忽略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.0.0-alpha+001</span><br><span class="line">1.0.0+20130313144700</span><br><span class="line">1.0.0-beta+exp.sha.5114f85</span><br></pre></td></tr></table></figure>



<h1 id="定义依赖版本号"><a href="#定义依赖版本号" class="headerlink" title="定义依赖版本号"></a>定义依赖版本号</h1><p>在 <a href="https://npmjs.com/" target="_blank" rel="noopener">npm</a> 的依赖的规则中，还有 <code>~</code>、<code>&gt;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>-</code>、<code>||</code>、<code>x</code>、<code>X</code>、<code>*</code> 等符号；当使用 <code>npm install XX</code> 时，被安装的依赖的版本号前会默认加上 <code>^</code> 符号。</p>
<ul>
<li><code>^</code> ：表示同一主版本号中，不小于指定版本号的版本号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#96;^2.2.1&#96; 对应主版本号为 2，不小于 &#96;2.2.1&#96; 的版本号，比如 &#96;2.2.1&#96;、&#96;2.2.2&#96;、&#96;2.3.0&#96; ,主版本号固定</span><br><span class="line">&#x2F;&#x2F; 当该依赖有最新版本时(eg:2.3.3)，npm install 会安装最新的依赖</span><br></pre></td></tr></table></figure>

<ul>
<li><code>~</code> ：表示同一主版本号和次版本号中，不小于指定版本号的版本号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;~2.2.1&#96; 对应主版本号为 2，次版本号为 2，不小于 &#96;2.2.1&#96; 的版本号，比如 &#96;2.2.1、2.2.2&#96;，主版本号和次版本号固定</span><br></pre></td></tr></table></figure>

<p>常用的就是上述两种情况，拿vue做个例子：</p>
<ul>
<li>项目兼容vue发布的次版本和补丁版本：”vue”: “^2.5.0”</li>
<li>项目只兼容vue发布的补丁版本：”vue”: “~2.5.0”（发布2.6.0不会更新）</li>
</ul>
<div class="note warning">
            <p><strong>npm 中 package-lock.json 的一些坑</strong></p><p>在 npm install 后，会生成一个 package-lock.json 文件用于保存当前安装依赖的各种来源及版本号。</p><p>在 npm 5.4.2版本后，package-lock.json 的变动规则：</p><ul><li>当在 install dependency 的指定版本时，会自动更新 package-lock.json 文件中该 dependency 的 version 到指定的 version</li><li>当在 install dependency 的范围版本时，当前的 version 低于或等于 package-lock.json 文件中对应的 dependency 的 version 时，会安装 package-lock.json 中的 version；</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&quot;antd&quot;: &quot;^3.6.1&quot;, &#x2F;&#x2F; eg：最新版本是 3.9.4</span><br><span class="line"></span><br><span class="line">package-lock.json</span><br><span class="line">&quot;antd&quot;: &quot;3.7.1&quot;,</span><br><span class="line"></span><br><span class="line">执行npm install 会安装 3.7.1 版本</span><br></pre></td></tr></table></figure><p>如果高于 package-lock.json 中对应的 dependency 的 version 时，会安装当前范围版本号中最高的版本，会更新 package-lock.json 文件中对应的版本号；</p><p>若版本使用<code>^</code>匹配符，想<code>临时</code>跳到某个固定版本，可以如下所示安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save antd@3.6.1</span><br></pre></td></tr></table></figure><p>若要固定版本，可以先删除<code>package-lock.json</code>，将<code>package.json</code>将antd改为<code>3.6.1</code>，不使用<code>匹配符</code>，执行<code>npm install</code></p>
          </div>



<h1 id="npm包发布"><a href="#npm包发布" class="headerlink" title="npm包发布"></a>npm包发布</h1><p>通常我们发布一个包到npm仓库时，我们的做法是先修改 <code>package.json</code> 为某个版本，然后执行 <code>npm publish</code> 命令。手动修改版本号的做法建立在你对Semver规范特别熟悉的基础之上，否则可能会造成版本混乱。npm 考虑到了这点，它提供了相关的命令来让我们更好的遵从Semver规范：</p>
<ul>
<li>升级补丁版本号：npm version patch</li>
<li>升级小版本号：npm version minor</li>
<li>升级大版本号：npm version major</li>
</ul>
<p>当执行 <code>npm publish</code> 时，会首先将当前版本发布到 <code>npm registry</code>，然后更新 <code>dist-tags.latest</code> 的值为新版本。</p>
<p>当执行 <code>npm publish --tag=next</code> 时，会首先将当前版本发布到 <code>npm registry</code>，并且更新 <code>dist-tags.next</code> 的值为新版本。这里的 next 可以是任意有意义的命名（比如：v1.x、v2.x 等等）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0</a></li>
<li><a href="https://www.jianshu.com/p/a7490344044f" target="_blank" rel="noopener">semver 语义化版本规范</a></li>
<li><a href="https://segmentfault.com/a/1190000014405355" target="_blank" rel="noopener">Semver(语义化版本号)扫盲</a></li>
</ul>
]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>SemVer</tag>
      </tags>
  </entry>
  <entry>
    <title>链表从后往前遍历</title>
    <url>/2020/07/25/%E9%93%BE%E8%A1%A8%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>现有一个链表结构:  1-&gt;2-&gt;3-&gt;4  尾结点+1，变成1-&gt;2-&gt;3-&gt;5, 但是要进位，就是1-&gt;2-&gt;3-&gt;9尾节点+1后变成1-&gt;2-&gt;4-&gt;0，以此类推；</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function increaseLinkedList (head) &#123;</span><br><span class="line">  &#x2F;&#x2F; 尾结点当作进位</span><br><span class="line">  if (head &#x3D;&#x3D;&#x3D; null) return true;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 是否被进位</span><br><span class="line">  var isCarry &#x3D; increaseLinkedList(head.next);</span><br><span class="line">  if (!isCarry) return false;</span><br><span class="line"></span><br><span class="line">  head.val &#x3D; ++head.val % 10;</span><br><span class="line">  return head.val &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面通过递归的方式解决例题，链表从后往前遍历常用的两种方法分别是递归和栈，它们的思想如下所示：</p>
<ul>
<li>递归: 链表的数据结构从后往前遍历刚好符合递归调用的一个顺序</li>
<li>栈：先进后出的特性</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>ESLint使用指南</title>
    <url>/2020/06/11/ESLint%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ESLint</code>是最流行的<code>JavaScript Linter</code>。</p>
<blockquote>
<p>Linter 是检查代码风格/错误的小工具。其他类似的 Linter 工具还有：TSLint、stylelint。</p>
</blockquote>
<p>它包含三个功能：</p>
<p>（1）check syntax</p>
<p>（2）find problems</p>
<p>前两个可以统称为 Code-quality rules，例如 <a href="http://eslint.org/docs/rules/no-unused-vars" target="_blank" rel="noopener">no-unused-vars </a>规则。</p>
<p>（3）enforce code style</p>
<p>最后一个可以称为 <strong>Formatting rules</strong> ，例如 <a href="http://eslint.org/docs/rules/keyword-spacing" target="_blank" rel="noopener">keyword-spacing</a> 规则。</p>
<a id="more"></a>

<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add eslint --dev</span><br></pre></td></tr></table></figure>



<h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><p>有两种主要的方式来配置 <code>ESLint</code>：</p>
<ul>
<li>代码注释（一般由编辑器修复，这种情况应考虑<code>.eslintrc.*</code>的配置，尽量不要有代码注释）</li>
<li>配置文件<a href="https://eslint.bootcss.com/docs/user-guide/configuring#configuration-file-formats" target="_blank" rel="noopener"><code>.eslintrc.*</code></a>或<code>package.json</code>中指定<code>eslintConfig</code>字段</li>
</ul>
<p>有很多信息可以配置：</p>
<ul>
<li><strong>Environments</strong> - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。</li>
<li><strong>Globals</strong> - 脚本在执行期间访问的额外的全局变量。</li>
<li><strong>Rules</strong> - 启用的规则及其各自的错误级别。</li>
</ul>
<div class="note danger">
            <p>非常用参数未详细列举出来，有兴趣的自行<a href="https://eslint.bootcss.com/docs/user-guide/configuring" target="_blank" rel="noopener">官网</a>学习。</p>
          </div>

<h2 id="parseOptions-指定解析选项"><a href="#parseOptions-指定解析选项" class="headerlink" title="parseOptions - 指定解析选项"></a>parseOptions - 指定解析选项</h2><ul>
<li><p><code>ecmaVersion</code> - 默认设置为 3，5（默认）， 你可以使用 6、7、8、9 或 10 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）或 2018（同 9）或 2019 (same as 10)</p>
</li>
<li><p><code>sourceType</code> - 设置为 <code>&quot;script&quot;</code> (默认) 或 <code>&quot;module&quot;</code>（如果你的代码是 ECMAScript 模块)。</p>
</li>
<li><p><code>ecmaFeatures</code> - 这是个对象，表示你想使用的额外的语言特性</p>
<ul>
<li><code>globalReturn</code> - 允许在全局作用域下使用 <code>return</code> 语句</li>
<li><code>impliedStrict</code> - 启用全局 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">strict mode</a> (如果 <code>ecmaVersion</code> 是 5 或更高)</li>
<li><code>jsx</code> - 启用 <a href="http://facebook.github.io/jsx/" target="_blank" rel="noopener">JSX</a></li>
<li><code>experimentalObjectRestSpread</code> - 启用实验性的 <a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">object rest/spread properties</a> 支持。</li>
</ul>
</li>
</ul>
<div class="note danger">
            <p>支持 ES6 语法并不意味着同时支持新的 ES6 全局变量或类型（比如 <code>Set</code> 等新类型）。对于 ES6 语法，使用 <code>{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }</code>；对于新的 ES6 全局变量，使用 <code>{ &quot;env&quot;:{ &quot;es6&quot;: true } }</code>。<code>{ &quot;env&quot;: { &quot;es6&quot;: true } }</code> 自动启用es6语法，但 <code>{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }</code> 不自动启用es6全局变量。</p>
          </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaVersion&quot;: 6,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;,</span><br><span class="line">        &quot;ecmaFeatures&quot;: &#123;</span><br><span class="line">            &quot;jsx&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="parser-指定解析器"><a href="#parser-指定解析器" class="headerlink" title="parser - 指定解析器"></a>parser - 指定解析器</h2><ul>
<li><a href="https://github.com/eslint/espree" target="_blank" rel="noopener">Espree</a></li>
<li><a href="https://www.npmjs.com/package/esprima" target="_blank" rel="noopener">Esprima</a></li>
<li><a href="https://www.npmjs.com/package/babel-eslint" target="_blank" rel="noopener">Babel-ESLint</a> - 一个对<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>解析器的包装，使其能够与 ESLint 兼容。</li>
<li><a href="https://www.npmjs.com/package/@typescript-eslint/parser" target="_blank" rel="noopener">@typescript-eslint/parser</a> - 将 TypeScript 转换成与 estree 兼容的形式，以便在ESLint中使用。</li>
</ul>
<div class="note danger">
            <p>Babel-ESLint官方说明了不要因为项目中使用了babel就使用该解析器。当ESLint解析器不能够支持某些实验性功能或者类型（Flow），才考虑使用Babel-ESLint解析器。</p>
          </div>

<p>例如，下面的配置指定了 Esprima 作为解析器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;parser&quot;: &quot;esprima&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="env-指定环境"><a href="#env-指定环境" class="headerlink" title="env - 指定环境"></a>env - 指定环境</h2><p>一个环境定义了一组预定义的全局变量。常用的环境如下所示:</p>
<ul>
<li><code>browser</code> - 浏览器环境中的全局变量。</li>
<li><code>node</code> - Node.js 全局变量和 Node.js 作用域</li>
<li><code>es6</code> - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 <code>ecmaVersion</code> 解析器选项为 6）</li>
<li><code>mocha</code> - 添加所有的 Mocha 测试全局变量。</li>
<li><code>jquery</code> - jQuery 全局变量</li>
<li>…</li>
</ul>
<p>例如，以下示例启用了 browser 和 Node.js 的环境：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="globals-指定全局变量"><a href="#globals-指定全局变量" class="headerlink" title="globals - 指定全局变量"></a>globals - 指定全局变量</h2><p>当访问当前源文件内未定义的变量时，<a href="https://eslint.bootcss.com/docs/rules/no-undef" target="_blank" rel="noopener">no-undef</a> 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。</p>
<p>对于每个全局变量键，将对应的值设置为 <code>&quot;writable&quot;</code> 以允许重写变量，或 <code>&quot;readonly&quot;</code> 不允许重写变量。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;var1&quot;: &quot;writable&quot;,</span><br><span class="line">        &quot;var2&quot;: &quot;readonly&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用字符串 <code>&quot;off&quot;</code> 禁用全局变量。例如，在大多数 ES2015 全局变量可用但 <code>Promise</code> 不可用的环境中，你可以使用以下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;es6&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;Promise&quot;: &quot;off&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger">
            <p><strong>注意：</strong>要启用<a href="https://eslint.bootcss.com/docs/rules/no-global-assign" target="_blank" rel="noopener">no-global-assign</a>规则来禁止对只读的全局变量进行修改。</p>
          </div>



<h2 id="plugins-配置插件"><a href="#plugins-配置插件" class="headerlink" title="plugins - 配置插件"></a>plugins - 配置插件</h2><p>例如，指定<code>eslint-plugin-vue</code>插件检测vue代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;vue&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="extends-规则继承"><a href="#extends-规则继承" class="headerlink" title="extends - 规则继承"></a>extends - 规则继承</h2><p>一个配置文件可以被基础配置中的已启用的规则继承。</p>
<p><code>extends</code> 属性值可以是：</p>
<ul>
<li>指定配置的字符串(配置文件的路径、可共享配置的名称、<code>eslint:recommended</code> 或 <code>eslint:all</code>)</li>
<li>字符串数组：每个配置继承它前面的配置</li>
</ul>
<p>例如，继承eslint推荐配置<code>eslint:recommended</code>，然后添加自定义的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;，</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &#x2F;&#x2F; enable additional rules</span><br><span class="line">        &quot;indent&quot;: [&quot;error&quot;, 4],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="eslintignore-忽略文件"><a href="#eslintignore-忽略文件" class="headerlink" title="eslintignore - 忽略文件"></a>eslintignore - 忽略文件</h2><p>同gitignore。例如，忽略node_modules目录的检测：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure>



<h1 id="构建Lint工作流"><a href="#构建Lint工作流" class="headerlink" title="构建Lint工作流"></a>构建Lint工作流</h1><p>下面以vue项目为例，具体插件和设置还需根据项目的依赖来配置。</p>
<h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>

<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200610230949.png" alt="image-20200610221320271"></p>
<h2 id="添加规则文件"><a href="#添加规则文件" class="headerlink" title="添加规则文件"></a>添加规则文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;es6&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:vue&#x2F;essential&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;globals&quot;: &#123;</span><br><span class="line">        &quot;Atomics&quot;: &quot;readonly&quot;,</span><br><span class="line">        &quot;SharedArrayBuffer&quot;: &quot;readonly&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">        &quot;ecmaVersion&quot;: 2018,</span><br><span class="line">        &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;vue&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">    	&#x2F;&#x2F; 添加自定义规则，同一团队代码风格</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="添加忽略文件-eslintignore"><a href="#添加忽略文件-eslintignore" class="headerlink" title="添加忽略文件.eslintignore"></a>添加忽略文件<code>.eslintignore</code></h3><p>根据项目添加忽略目录，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dist</span><br><span class="line">node_modules</span><br><span class="line">.idea</span><br></pre></td></tr></table></figure>



<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a><a href="https://eslint.bootcss.com/docs/user-guide/integrations" target="_blank" rel="noopener">集成</a></h2><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li><p>Visual Studio Code: <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint Extension</a></p>
</li>
<li><p>WebStorm</p>
<p>  File &gt; settings &gt; Languages &amp; Frameworks&gt; Javascript &gt; Code Quality Tools &gt; ESLint</p>
</li>
</ul>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><h4 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h4><h5 id="安装rollup-plugin-eslint"><a href="#安装rollup-plugin-eslint" class="headerlink" title="安装rollup-plugin-eslint"></a>安装rollup-plugin-eslint</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add rollup-plugin-eslint --dev</span><br></pre></td></tr></table></figure>

<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; eslint &#125; from &quot;rollup-plugin-eslint&quot;;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">  input: &quot;main.js&quot;,</span><br><span class="line">  plugins: [</span><br><span class="line">    eslint()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><h4 id="安装eslint-loader"><a href="#安装eslint-loader" class="headerlink" title="安装eslint-loader"></a>安装eslint-loader</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add eslint-loader --dev</span><br></pre></td></tr></table></figure>

<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        exclude: &#x2F;node_modules&#x2F;,</span><br><span class="line">        use: [&#39;babel-loader&#39;, &#39;eslint-loader&#39;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="Git-hooks"><a href="#Git-hooks" class="headerlink" title="Git hooks"></a>Git hooks</h1><h2 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D husky lint-staged pretty-quick</span><br></pre></td></tr></table></figure>



<h2 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">...其他脚本命令</span><br><span class="line">      &quot;precommit&quot;: &quot;pretty-quick --staged&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">      &quot;src&#x2F;**&#x2F;*.&#123;js,jsx&#125;&quot;: [</span><br><span class="line">          &quot;eslint --fix&quot;,</span><br><span class="line">          &quot;git add&quot;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;husky&quot;: &#123;</span><br><span class="line">      &quot;hooks&quot;: &#123;</span><br><span class="line">          &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h1 id="个人常用规则"><a href="#个人常用规则" class="headerlink" title="个人常用规则"></a>个人常用规则</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">        indent: [&#39;error&#39;, 4]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://eslint.bootcss.com/" target="_blank" rel="noopener">ESLint官网</a></li>
<li><a href="https://www.cnblogs.com/xjnotxj/p/10828183.html" target="_blank" rel="noopener">VSCode 使用 ESLint + Prettier 来统一 JS 代码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53680918" target="_blank" rel="noopener">ESLint 工作原理探讨</a></li>
<li><a href="https://github.com/AlloyTeam/eslint-config-alloy/blob/master/README.zh-CN.md" target="_blank" rel="noopener">AlloyTeam 规范</a></li>
<li><a href="https://segmentfault.com/a/1190000022881634" target="_blank" rel="noopener">从零构建前端 Lint 工作流</a></li>
<li><a href="https://coderwall.com/p/zq8jlq/eslint-pre-commit-hook" target="_blank" rel="noopener">Git Precommit Hook</a></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客系列：（一）搭建属于自己的博客网站</title>
    <url>/2020/05/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本教程是对Hexo+NexT博客部署到GitHub Pages的总结，你可以参照这个教程搭建出基本能用的博客网站，若你有自己的想法，可以自己参考相关文档进行个性化配置。针对后续我自己博客的个性化配置，我会在这一系列教程的其他教程中一一列举出来。</p>
<a id="more"></a>

<h1 id="Hexo建站"><a href="#Hexo建站" class="headerlink" title="Hexo建站"></a>Hexo建站</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个基于<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>的静态博客框架，它使用Markdown(或其他渲染引擎)解析文章，快速且高效。</p>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>需要先安装下列应用程序：</p>
<ul>
<li>Node.js(最新版本，我的版本是V.12.13.0)</li>
<li>Git</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，文件夹目录如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a>信息。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。</p>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a>文件夹。当您新建文章时，Hexo 会根据scaffold来建立文件。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为<code>_</code>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到<code>public</code>文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a>文件夹。Hexo会根据主题来生成静态页面。</p>
<h1 id="NexT主题"><a href="#NexT主题" class="headerlink" title="NexT主题"></a>NexT主题</h1><p><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">NexT</a>是Hexo主题中最受欢迎的一款主题（star最多），风格简洁，确实很好看。HexT的GitHub代码仓库经常变动，主要是下列3个仓库:</p>
<ul>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">2014-2017版本(当前最新V5.1.4)</a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">2018-2019(当前最新V7.8.0)</a></li>
<li><a href="https://github.com/next-theme/hexo-theme-next" target="_blank" rel="noopener">2020(<code>当前最新版本v8.0.0-rc.2，使用版本</code>)</a></li>
</ul>
<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为<code>站点配置文件</code>， 后者称为<code>主题配置文件</code></p>
<h2 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h2><p>Hexo主题安装非常简单，只需要将主题文件拷贝至站点目录<code>themes</code>目录下，将主题目录命名为<code>next</code>。</p>
<h2 id="启动主题"><a href="#启动主题" class="headerlink" title="启动主题"></a>启动主题</h2><p>打开<code>站点配置文件</code>， 找到<code>theme</code>字段，并将其值更改为<code>next</code>。</p>
<h2 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm run server</span><br></pre></td></tr></table></figure>
<p>使用浏览器访问<code>http://localhost:4000</code>，检查站点是否正确运行。<img src="https://yuanchangjian.github.io/cloudImage/images/20200515102636697.png" alt="image-20200515102636697"></p>
<p>现在，你已经成功安装并启用了 NexT 主题。下一步我们将对主题进行个性化配置。</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>主题生效后，我们便开始配置主题的基本设置。</p>
<h3 id="设置站点标题"><a href="#设置站点标题" class="headerlink" title="设置站点标题"></a>设置站点标题</h3><p>编辑<code>站点配置文件</code>， 将<code>title</code>设置成你的站点标题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Ycj&#39;s Blog</span><br></pre></td></tr></table></figure>

<h3 id="设置站点描述"><a href="#设置站点描述" class="headerlink" title="设置站点描述"></a>设置站点描述</h3><p>编辑<code>站点配置文件</code>， 设置<code>description</code>字段为你的站点描述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">description: 我是要成为海贼王的男人</span><br></pre></td></tr></table></figure>

<h3 id="设置作者昵称"><a href="#设置作者昵称" class="headerlink" title="设置作者昵称"></a>设置作者昵称</h3><p>编辑<code>站点配置文件</code>， 设置<code>author</code>为你的昵称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author: Ycj</span><br></pre></td></tr></table></figure>

<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>编辑<code>站点配置文件</code>， 将<code>language</code>设置成你所需要的语言。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>

<h3 id="设置外观"><a href="#设置外观" class="headerlink" title="设置外观"></a>设置外观</h3><p>Scheme 的切换通过更改<code>主题配置文件</code>，搜索<code>scheme</code>关键字。目前NexT支持四种外观，分别是：</p>
<ul>
<li>Muse</li>
<li>Mist</li>
<li>Pisces</li>
<li>Gemini</li>
</ul>
<p>我比较喜欢<code>Mist</code>这种风格，你可以自己都尝试一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>NexT默认菜单项如下所示，我当前使用了<code>home(首页)</code>、<code>categories(分类)</code>、<code>archives(归档)</code>、<code>tags(标签)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  # about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  # schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  # sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  # commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<h4 id="添加「分类」页面"><a href="#添加「分类」页面" class="headerlink" title="添加「分类」页面"></a>添加「分类」页面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>将新建的source/categories目录下的index.md增加type说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: categories</span><br><span class="line">date: 2020-05-12 10:55:35</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="添加「标签」页面"><a href="#添加「标签」页面" class="headerlink" title="添加「标签」页面"></a>添加「标签」页面</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>将新建的<code>source/tags</code>目录下的<code>index.md</code>增加<code>type</code>说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: tags</span><br><span class="line">date: 2020-05-12 10:56:30</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="文章中添加标签和分类"><a href="#文章中添加标签和分类" class="headerlink" title="文章中添加标签和分类"></a>文章中添加标签和分类</h4><p>你可以在<code>文章</code>中的<code>Front-matter</code>中增加分类和标签，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<div class="note danger">
            <p><strong>分类方法的分歧</strong></p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>
          </div>

<h3 id="设置侧栏"><a href="#设置侧栏" class="headerlink" title="设置侧栏"></a>设置侧栏</h3><p>可以通过修改<code>主题配置文件</code>中的<code>sidebar</code>字段来控制侧栏的行为。设置侧栏的位置，修改<code>sidebar.position</code>的值，支持的选项有：</p>
<ul>
<li>left - 靠左放置</li>
<li>right - 靠右放置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  #position: left</span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure>

<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>编辑<code>主题配置文件</code>， 修改<code>avatar</code>下的<code>url</code>字段，url可以是站内或完整的互联网URI:</p>
<ul>
<li>完整的互联网URI</li>
<li>站点内的地址，放置在主题<code>source/images/</code>目录下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.gif</span><br></pre></td></tr></table></figure>

<h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p>安装<code>hexo-generator-feed</code>插件，它是hexo博客专门生成RSS xml文件的插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>编辑<code>站点配置文件</code>，在文件末尾添加下列配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rss配置</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>RSS自动生成按钮在NexT V7.6.0版本移除，V7.6.0以下的NexT版本的博客网站普遍都有一个RSS按钮，不用担心，我们可以通过下面提到的设置社交链接展示出来。 </p>
          </div>

<h3 id="设置社交链接"><a href="#设置社交链接" class="headerlink" title="设置社交链接"></a>设置社交链接</h3><p>编辑<code>主题配置文件</code>， 在<code>social</code>中添加社交链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;yuanchangjian || fab fa-github</span><br><span class="line">  RSS: &#x2F;atom.xml || fa fa-rss</span><br><span class="line">  # 等等</span><br></pre></td></tr></table></figure>

<h3 id="设置友情链接"><a href="#设置友情链接" class="headerlink" title="设置友情链接"></a>设置友情链接</h3><p>编辑<code>主题配置文件</code>，在<code>links</code>下添加你的友情链接地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">links:</span><br><span class="line">  CoolShell: https:&#x2F;&#x2F;coolshell.cn&#x2F;</span><br><span class="line">  Eric: &#39;https:&#x2F;&#x2F;github.com&#x2F;lizhaoting&#39;</span><br></pre></td></tr></table></figure>

<h3 id="添加腾讯公益404页面"><a href="#添加腾讯公益404页面" class="headerlink" title="添加腾讯公益404页面"></a>添加腾讯公益404页面</h3><p>腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！<br>使用方法，新建<code>404.html</code>页面，放到主题的<code>source</code>目录下，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;style&#x2F;404style.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;plain&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot;</span><br><span class="line">          charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;&#x2F;&quot;</span><br><span class="line">          homePageName&#x3D;&quot;回到我的主页&quot;&gt;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;data.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;page.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="设置站点建立时间"><a href="#设置站点建立时间" class="headerlink" title="设置站点建立时间"></a>设置站点建立时间</h3><p>这个时间将在站点的底部显示，例如 © 2020 - 2022。 编辑<code>主题配置文件</code>，修改<code>since</code>字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2020</span><br></pre></td></tr></table></figure>

<p>现在，你已经完成了主题的基本配置，页面展示如下所示：</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515110050.png" alt="image-20200515110048107"></p>
<hr>
<h2 id="集成常用的第三方服务"><a href="#集成常用的第三方服务" class="headerlink" title="集成常用的第三方服务"></a>集成常用的第三方服务</h2><h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>相较官网提供几种<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-system" target="_blank" rel="noopener">搜索服务</a>，我这里使用的是<code>Local Search</code>，提供一个页面快速文章的功能。</p>
<ol>
<li><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <strong>站点配置文件</strong>，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <strong>主题配置文件</strong>，启用本地搜索功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>重启应用，效果如下：<img src="https://yuanchangjian.github.io/cloudImage/images/20200515110300.png" alt="image-20200515110258588"></p>
<h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>我这里使用了<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">不蒜子统计</a>+LeanCloud实现站内的数据统计，这里提及一下，不蒜子现在版本对于首页多个文章无法统计阅读量，所以我i将不蒜子是用来统计网站访问量和用户量，LeanCloud用来统计文章的阅读量。</p>
<ul>
<li><p>不蒜子统计</p>
<p>编辑主题配置文件，找到<code>busuanzi_count</code>字段，修改为如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>效果图如下（统计数不对是因为开发环境如此，部署会正确展示）：<img src="https://yuanchangjian.github.io/cloudImage/images/20200515111953.png" alt="image-20200515111951296"></p>
<ul>
<li><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></li>
</ul>
<ol>
<li><p>创建应用</p>
<p>应用名随意填写，不满意后续可更改。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515113114.png" alt="image-20200515113112829"></p>
</li>
<li><p>新建Class</p>
<p>为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字必须为<code>Counter</code>。</p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515113917.png" alt="image-20200515113916349"></p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515113950.png" alt="image-20200515113948683"></p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515115930.png" alt="image-20200515114552823"></p>
</li>
</ol>
<ol start="3">
<li><p>配置LeanCloud</p>
<p>获取<code>app_id</code>和<code>app_key</code></p>
<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515115919.png" alt="image-20200515115918389"></p>
<p>编辑主题配置文件，找到<code>leancloud_visitors</code>字段，将你的<code>app_id</code>和<code>app_key</code>填上，并修改<code>security</code>为<code>false</code>，修改为如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: ture</span><br><span class="line">  app_id: xxx # &lt;your app id&gt;</span><br><span class="line">  app_key: xxx # &lt;your app key&gt;</span><br><span class="line">  server_url: # &lt;your server url&gt;</span><br><span class="line">  security: false</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="部署至GitHub-Pages"><a href="#部署至GitHub-Pages" class="headerlink" title="部署至GitHub Pages"></a>部署至GitHub Pages</h1><p>部署参考<a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">官网部署教程</a>，这里我列出来是因为我想通过<code>&lt;GitHub 用户名&gt;.github.io</code>访问博客，但我发现<code>GitHub Pages</code>的部署分支只能为<code>master</code>，所以我修改了<code>.travis.yaml</code>文件，使我们在其他分支中（如：<code>hexo</code>）开发，而通过Travis CI工具部署至<code>master</code>分支，从而保证<code>&lt;GitHub 用户名&gt;.github.io</code>能正常访问。</p>
<p>如果你不需要<code>&lt;GitHub 用户名&gt;.github.io</code>如此访问，可以接受<code>&lt;GitHub 用户名&gt;.github.io/xxx</code>访问就无需更改<code>.travis.yaml</code>文件，可以跳过本小节教程，直接参考官网部署教程。</p>
<ol>
<li><p>新建一个 repository。如果你希望你的站点能通过 <code>&lt;GitHub 用户名&gt;.github.io</code> 域名访问，你的 repository 应该直接命名为 <code>&lt;GitHub 用户名&gt;.github.io</code>。</p>
</li>
<li><p>将你的 Hexo 站点文件夹推送到 repository 中。默认情况下不应该 <code>public</code> 目录将不会被推送到 repository 中，你应该检查 <code>.gitignore</code> 文件中是否包含 <code>public</code> 一行，如果没有请加上。</p>
</li>
<li><p>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</p>
</li>
<li><p>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</p>
</li>
<li><p>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/" target="_blank" rel="noopener">手动前往</a>。</p>
</li>
<li><p>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</p>
</li>
<li><p>回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存。</p>
</li>
<li><p><strong>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - hexo # build master branch only (修改点：master -&gt; hexo)</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: hexo # (修改点：master -&gt; hexo)</span><br><span class="line">  local-dir: public</span><br><span class="line">  target-branch: master # (增加项：将hexo分支编译到master分支部署)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官方网站</a></p>
</li>
<li><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Hexo官方使用文档</a></p>
</li>
<li><p><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p>
</li>
<li><p><a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">Travis CI官方说明文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hexo搭建博客系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块化历程</title>
    <url>/2020/05/19/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>到目前为止，JavaScript模块化大概分为以下几个里程碑式节点。</p>
<ul>
<li><p>函数块</p>
</li>
<li><p>命名空间</p>
</li>
<li><p>闭包</p>
</li>
<li><p>CommonJS</p>
</li>
<li><p>AMD</p>
</li>
<li><p>CMD</p>
</li>
<li><p>UMD</p>
</li>
<li><p>ES6Module</p>
</li>
</ul>
<a id="more"></a>

<h1 id="函数块"><a href="#函数块" class="headerlink" title="函数块"></a>函数块</h1><p>最早，我们这么写代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>Global 被污染，很容易命名冲突</p>
          </div>



<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.foo();</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <ul><li><p>减少 Global 上的变量数目</p></li><li><p>本质是对象，一点都不安全</p></li></ul>
          </div>



<h1 id="闭包（IIFE-模式）"><a href="#闭包（IIFE-模式）" class="headerlink" title="闭包（IIFE 模式）"></a>闭包（IIFE 模式）</h1><h2 id="匿名闭包"><a href="#匿名闭包" class="headerlink" title="匿名闭包"></a>匿名闭包</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _private = <span class="string">"safe now"</span>;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(_private)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Module.foo();</span><br><span class="line">Module._private; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>函数是 JavaScript 唯一的 Local Scope</p>
          </div>



<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _$body = $(<span class="string">"body"</span>);     <span class="comment">// we can use jQuery now!</span></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(_$body);    <span class="comment">// 特权方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Revelation Pattern</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery)</span><br><span class="line"></span><br><span class="line">Module.foo();</span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>这就是模块模式，也是现代模块实现的基石</p>
          </div>



<h1 id="CommonJS-amp-amp-Node-js-2009"><a href="#CommonJS-amp-amp-Node-js-2009" class="headerlink" title="CommonJS &amp;&amp; Node.js(2009)"></a><a href="http://www.commonjs.org/" target="_blank" rel="noopener">CommonJS</a> &amp;&amp; <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>(2009)</h1><p><code>CommonJS</code>规范，主要运行于<code>服务器端</code>，一个单独的文件就是一个模块，<code>同步加载</code>模块。<code>Node.js</code>很好的实现了该规范。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)	<span class="comment">// 同步加载并执行</span></span><br><span class="line"><span class="built_in">console</span>.log(module1.add(<span class="number">1</span>, <span class="number">2</span>));    	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<div class="note warning">
            <p>同步/阻塞式加载</p>
          </div>


<p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519222015.png" alt="image-20200520112846849"></p>
<h1 id="AMD-amp-amp-Require-js-2011"><a href="#AMD-amp-amp-Require-js-2011" class="headerlink" title="AMD &amp;&amp; Require.js(2011)"></a><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> &amp;&amp; <a href="https://requirejs.org/" target="_blank" rel="noopener">Require.js</a>(2011)</h1><p>AMD(Asynchronous Module Definition - 异步加载模块定义)规范，一个单独的文件就是一个模块，模块和模块的依赖可以被<code>异步加载</code>。主要运行于<code>浏览器端</code>。该规范是在Require.js的推广过程中逐渐完善的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line">define(</span><br><span class="line">    [<span class="string">'jQuery'</span>,<span class="string">'lodash'</span>], 	<span class="comment">// 依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">$, _</span>) </span>&#123;	    <span class="comment">// 这个回调会在所有依赖都被加载后才执行</span></span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'weiqinl'</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name,</span><br><span class="line">            foo</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    a.name === <span class="string">'weiqinl'</span> <span class="comment">// true</span></span><br><span class="line">    a.foo() <span class="comment">// 执行A模块中的foo函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;script src=<span class="string">"js/require.js"</span> data-main=<span class="string">"js/index"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="AMD-vs-CommonJS"><a href="#AMD-vs-CommonJS" class="headerlink" title="AMD vs CommonJS"></a>AMD vs CommonJS</h2><ul>
<li>书写风格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Module/1.0</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);  <span class="comment">// 依赖就近</span></span><br><span class="line">a.doSomething();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>)</span><br><span class="line">b.doSomething();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AMD recommended style</span></span><br><span class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="comment">// 依赖前置</span></span><br><span class="line">    a.doSomething();</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>执行时机</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Module/1.0</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);  <span class="comment">// 执行到此时，a.js 同步下载并执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AMD with CommonJS sugar</span></span><br><span class="line">define([<span class="string">"require"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在这里， a.js 已经下载并且执行好了</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>AMD的运行逻辑是：<strong>提前加载</strong>，<strong>提前执行</strong>。在Require.js中，申明依赖模块时，会第一时间加载并执行模块内的代码，使后面的回调函数能在所需的环境中运行。</p>
<h1 id="CMD-amp-amp-Sea-js-2011"><a href="#CMD-amp-amp-Sea-js-2011" class="headerlink" title="CMD &amp;&amp; Sea.js(2011)"></a><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener">CMD</a> &amp;&amp; Sea.js(2011)</h1><p>CMD(Common Module Definition - 通用模块定义)规范主要是Sea.js推广中形成的，一个文件就是一个模块，可以像Node.js一般书写模块代码。主要在浏览器中运行，当然也可以在Node.js中运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>) <span class="comment">// 到此才会加载a模块</span></span><br><span class="line">        a.func()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 到此才会加载b模块，此处条件不法进入，不会加载</span></span><br><span class="line">            b.func() 	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    exports.func = func;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 加载使用模块</span></span><br><span class="line">seajs.use(<span class="string">'moduleA.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ma</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ma = math.func()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML，需要在页面中引入sea.js文件。</span></span><br><span class="line">&lt;script src=<span class="string">"./js/sea.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>js/index.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="AMD-VS-CMD"><a href="#AMD-VS-CMD" class="headerlink" title="AMD VS CMD"></a>AMD VS CMD</h2><ul>
<li>执行时机</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AMD recommended</span></span><br><span class="line">define([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    a.doSomething();    <span class="comment">// 依赖前置，提前执行</span></span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD recommanded</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"a"</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"b"</span>);</span><br><span class="line">    b.doSomething();    <span class="comment">// 依赖就近，延迟执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>CMD推崇<strong>依赖就近</strong>，<strong>延迟执行</strong>。在上面例子中，通过require引入的模块，只有当程序运行到此处的时候，模块才会自动加载执行。</p>
<h1 id="UMD-amp-amp-webpack"><a href="#UMD-amp-amp-webpack" class="headerlink" title="UMD &amp;&amp; webpack"></a>UMD &amp;&amp; webpack</h1><p>UMD(Universal Module Definition - 通用模块定义)模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Node, AMD 或 browser globals 模式创建模块</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD模式. 注册为一个匿名函数</span></span><br><span class="line">        define([<span class="string">'b'</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">        <span class="comment">// Node等类CommonJS的环境</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'b'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 浏览器全局变量 (root is window)</span></span><br><span class="line">        root.returnExports = factory(root.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span> ? self : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以某种方式使用 b</span></span><br><span class="line">    <span class="comment">//返回一个值来定义模块导出。(即可以返回对象，也可以返回函数)</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<ol>
<li>判断<code>define</code>为函数，并且是否存在<code>define.amd</code>，来判断是否为<code>AMD规范</code></li>
<li>判断<code>module</code>是否为一个对象，并且是否存在<code>module.exports</code>来判断是否为<code>CommonJS规范</code></li>
<li>如果以上两种都没有，设定为原始的代码规范</li>
</ol>
<p>这种模式，通常会在<code>webpack</code>打包的时候用到。<code>output.libraryTarget</code>将模块以哪种规范的文件输出。</p>
<h1 id="ES6-Module-amp-amp-ES6"><a href="#ES6-Module-amp-amp-ES6" class="headerlink" title="ES6 Module &amp;&amp; ES6"></a>ES6 Module &amp;&amp; ES6</h1><p>在ECMAScript 2015版本出来之后，确定了一种新的模块加载方式，我们称之为ES6 Module。它和前几种方式有区别和相同点。</p>
<ol>
<li>它因为是标准，所以未来很多浏览器会支持，可以很方便的在浏览器中使用。</li>
<li>它同时兼容在<code>node</code>环境下运行。</li>
<li>模块的导入导出，通过<code>import</code>和<code>export</code>来确定。</li>
<li>可以和<code>Commonjs</code>模块混合使用。</li>
<li><code>CommonJS</code>输出的是一个<strong>值的拷贝</strong>。ES6模块输出的是<strong>值的引用</strong>,加载的时候会做静态优化。</li>
<li><code>CommonJS</code>模块是运行时加载确定输出接口，ES6模块是编译时确定输出接口。</li>
</ol>
<p>ES6模块功能主要由两个命令构成：<code>import</code>和<code>export</code>。<code>import</code>命令用于输入其他模块提供的功能。<code>export</code>命令用于规范模块的对外接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">'weiqinl'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="string">'2018'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出一个对象（推荐）</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'weiqinl'</span></span><br><span class="line"><span class="keyword">var</span> year = <span class="string">'2018'</span></span><br><span class="line"><span class="keyword">export</span> &#123; name, year&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export default 命令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>import导入其他模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常命令</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, year &#125; <span class="keyword">from</span> <span class="string">'./module.js'</span> <span class="comment">//后缀.js不能省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果遇到export default命令导出的模块</span></span><br><span class="line"><span class="keyword">import</span> ed <span class="keyword">from</span> <span class="string">'./export-default.js'</span></span><br></pre></td></tr></table></figure>



<h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><p>浏览器加载ES6模块，使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性<br>外链js文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以内嵌在网页中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// other code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于加载外部模块，需要注意：</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<h2 id="Node加载"><a href="#Node加载" class="headerlink" title="Node加载"></a>Node加载</h2><p>Node要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，就必须采用<code>.mjs</code>后缀名。<br>这个功能还在试验阶段。安装<code>Node V8.5.0</code>或以上版本，要用<code>--experimental-modules</code>参数才能打开该功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node --experimental-modules my-app.mjs</span><br></pre></td></tr></table></figure>

<p><code>Node</code>的<code>import</code>命令只支持异步加载本地模块(<code>file:</code>协议)，不支持加载远程模块。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要描述了JavaScript的模块化历程，以史为鉴，可以知兴替。每种技术的出现都是为了解决一些痛点的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/weiqinl/p/9940549.html" target="_blank" rel="noopener">JavaScript模块化CommonJS/AMD/CMD/UMD/ES6Module的区别</a></li>
<li><a href="https://github.com/weiqinl/demo/tree/master/js-module" target="_blank" rel="noopener">各模块化使用的例子</a></li>
<li><a href="https://requirejs.org/" target="_blank" rel="noopener">Require.js</a></li>
<li><a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">Sea.js</a></li>
<li><a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">ES6 Module</a></li>
<li><a href="http://huangxuan.me/js-module-7day/#/" target="_blank" rel="noopener">JavaScript模块化七日谈</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript模块化</tag>
      </tags>
  </entry>
</search>
