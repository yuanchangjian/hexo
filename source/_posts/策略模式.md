---
title: 策略模式
date: 2020-05-28 17:07:01
categories: 设计模式
tags:
	- 策略模式
	- 行为型模式
---



# 简介

策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。

# 结构

策略模式把对象本身和运算规则区分开来，因此我们整个模式也分为三个部分：

* 环境类(Context):用来操作策略的上下文环境
* 抽象策略类(Strategy):策略的抽象
* 具体的策略实现(ConcreteStrategyA、ConcreteStrategyB)

![image-20200528175353400](https://yuanchangjian.github.io/cloudImage/images/20200528175354.png)



<!-- more -->

# 示例：拼装功能

举一个例子，处理电商系统中的订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。

```
// Strategy：计费策略
interface BillingStrategy {
    public double GetActPrice(double rawPrice);
}

// ConcreteStrategyA：正常计费
// Normal billing strategy (unchanged price)
class NormalStrategy implements BillingStrategy {
    @Override
    public double GetActPrice(double rawPrice) {
        return rawPrice;
    }
}

// ConcreteStrategyB：打折(5折)收费
// Strategy for Happy hour (50% discount)
class HappyHourStrategy implements BillingStrategy {
    @Override
    public double GetActPrice(double rawPrice) {
        return rawPrice * 0.5;
    }
}


class OrderItem {
    // 名称
    public String Name; 
    // 价格
    public double Price; 
    // 数量
    public int Quantity;
    // 计费策略
    public BillingStrategy Strategy; 
    
    public OrderItem(String name, double price, int quantity, BillingStrategy strategy) {
        this.Name = name;
        this.Price = price;
        this.Quantity = quantity;
        this.Strategy = strategy;
    }
}

// Context： 订单处理上下文环境
class Order {
    // 订单列表
    private List<OrderItem> orderItems = new ArrayList<OrderItem>();

    // 添加订单项
    public void Add(String name, double price, int quantity, BillingStrategy strategy) {
        orderItems.add(new OrderItem(name, price, quantity, strategy));
    }
    
    // Payment of bill
    public void PayBill() {
        double sum = 0;
        for (OrderItem item : orderItems) {
            // 根据订单的不同策略计算
            double actPrice = item.Strategy.GetActPrice(item.price * item.quantity);
            sum += actPrice;
            
            System.out.println("%s -- %f(%d) - %f", 
                item.name, item.price, item.quantity, actPrice);
        }
        System.out.println("Total due: " + sum);
    }
}

// Client
class StrategyPattern {
	public static void main(String[] args) {
		Order order = new Order();
		// 添加正常商品
		order.add(new OrderItem("商品", 10, 10, new NormalStrategy()));
 		// 添加打折商品
		order.add(new OrderItem("商品", 10, 10, new HappyHourStrategy()));
		// 计算总价
		order.PayBill();
	}
}
```



# 总结

策略模式是一个比较容易理解和使用的设计模式，它将同一行为的每个不同实现都封单独装成一个类。这样便于将对象本身和运算规则分离，同时也便于运算规则的横向扩展。



# 参考

[维基百科-策略模式](https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F)

[编程范式游记（6）- 面向对象编程](https://time.geekbang.org/column/article/2729)