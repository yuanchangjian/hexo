---
title: 桥接模式
date: 2020-05-28 15:07:01
categories: 设计模式
tags:
	- 结构型模式
	- 桥接模式
---



# 简介

**桥接模式**是把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。



# 结构

![image-20200528152550208](https://yuanchangjian.github.io/cloudImage/images/20200528171528.png)



**Abstraction**

定义抽象的接口，该接口包含实现具体行为、具体特征的Implementor接口

**Refined Abstraction**

抽象接口Abstraction的子类，依旧是一个抽象的事物名

**Implementor**

定义具体行为、具体特征的应用接口

**ConcreteImplementor**

实现Implementor接口

<!-- more -->

# 示例：拼装对象

我们先来看一个示例，假设我们有如下的描述：

* 四个物体：木头桌子、木头椅子、塑料桌子、塑料椅子
* 五个属性：燃点、密度、价格、体积、重量（由密度和体积属性得出）

那么，我们怎么用面向对象的方式来设计我们的类呢？参看下图：

![image-20200528154626071](https://yuanchangjian.github.io/cloudImage/images/20200528171535.png)

```
// Implementor：材料类
class Material {
    // 密度
    private double density;
    // 燃点
    private double burning;
    
    public Material(double density, double burning) { 
        this.density = density; 
        this.burning = burning; 
    } 
    
    public double getDensity () {
        return this.density;
    }
    
    public double getBurningPoint () {
        return this.burning;
    }
}

// ConcreteImplementor: 木头
class Wood extends Material {
    public Wood(double density, double burning) { 
        super(density, burning); 
    }
}

// ConcreteImplementor: 塑料
class Plastic extends Material {
    public Plastic(double density, double burning) { 
        super(density, burning); 
    }
}

// Abstraction：家具类
class Furnlture {
    // 体积
    private double volume;
    // 价格
    private double price;
    // 材料
    private Material material;
    
    public Furnlture(double volume, double price, Material material) {
        this.density = density;
        this.burning = burning;         
        this.material = material;
    }
    
    // 获取重量
    public double getWeight () {
        return this.volume * this.material.getDensity();
    }
    ...
}

// Refined Abstraction: 桌子
class Table extends Furnlture {
    public Table(double volume, double price, Material material) { 
        super(volume, price, material); 
    }
}

// Refined Abstraction: 桌子
class Desk extends Furnlture {
    public Desk(double volume, double price, Material material) { 
        super(volume, price, material); 
    }
}

// Client
class BridgePattern {
   public static void main(String[] args)
   {
       // 木头桌子
       Furnlture table = new Table(1, 2, new Wood(1, 2));
       table.getWeight();// 获取木头桌子重量
       // 塑料
       Furnlture desk = new Desk(1, 2, new Plastic(1, 2));
       table.getWeight();// 获取塑料椅子重量
       ...
   }
}
```

这样设计的优点显而易见，它能和现实世界相对应起来，而且，材料类是可以重用的。因此当一个问题有多个维度且每个维度可独立扩展时，使用桥接模式可以将具体特征分离开。如上述例子，若不采用桥接模式，我们需要多继承或将多个属性加入**Abstraction**中，若加入属性存在功能扩展就增加了**Abstraction**类的复杂度。

# 总结

桥接模式表现了面向对象的拼装数据的另一个精髓——喜欢组合，而不是继承



# 参考

* [桥接模式-维基百科](https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F)

* [编程范式游记（6）- 面向对象编程](https://time.geekbang.org/column/article/2729)

