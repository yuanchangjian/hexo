<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ycj&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuanchangjian.github.io/"/>
  <updated>2020-05-20T06:32:27.261Z</updated>
  <id>https://yuanchangjian.github.io/</id>
  
  <author>
    <name>Ycj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript模块化历程</title>
    <link href="https://yuanchangjian.github.io/2020/05/19/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%86%E7%A8%8B/"/>
    <id>https://yuanchangjian.github.io/2020/05/19/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%86%E7%A8%8B/</id>
    <published>2020-05-19T13:34:01.000Z</published>
    <updated>2020-05-20T06:32:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript模块化历程"><a href="#JavaScript模块化历程" class="headerlink" title="JavaScript模块化历程"></a>JavaScript模块化历程</h1><p>到目前为止，大概分为以下几个里程碑式节点。</p><ul><li><p>函数块</p></li><li><p>命名空间</p></li><li><p>闭包</p></li><li><p>CommonJS</p></li><li><p>AMD</p></li><li><p>CMD</p></li><li><p>UMD</p></li><li><p>ES6Module</p></li></ul><a id="more"></a><h1 id="函数块"><a href="#函数块" class="headerlink" title="函数块"></a>函数块</h1><p>最早，我们这么写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;</span><br><span class="line">function bar() &#123;&#125;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>Global 被污染，很容易命名冲突</p>          </div><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var MYAPP &#x3D; &#123;</span><br><span class="line">    foo: function()&#123;&#125;,</span><br><span class="line">    bar: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYAPP.foo();</span><br></pre></td></tr></table></figure><div class="note warning">            <ul><li><p>减少 Global 上的变量数目</p></li><li><p>本质是对象，一点都不安全</p></li></ul>          </div><h1 id="闭包（IIFE-模式）"><a href="#闭包（IIFE-模式）" class="headerlink" title="闭包（IIFE 模式）"></a>闭包（IIFE 模式）</h1><h2 id="匿名闭包"><a href="#匿名闭包" class="headerlink" title="匿名闭包"></a>匿名闭包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Module &#x3D; (function()&#123;</span><br><span class="line">    var _private &#x3D; &quot;safe now&quot;;</span><br><span class="line">    var foo &#x3D; function()&#123;</span><br><span class="line">        console.log(_private)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        foo: foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Module.foo();</span><br><span class="line">Module._private; &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure><div class="note warning">            <p>函数是 JavaScript 唯一的 Local Scope</p>          </div><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Module &#x3D; (function($)&#123;</span><br><span class="line">    var _$body &#x3D; $(&quot;body&quot;);     &#x2F;&#x2F; we can use jQuery now!</span><br><span class="line">    var foo &#x3D; function()&#123;</span><br><span class="line">        console.log(_$body);    &#x2F;&#x2F; 特权方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Revelation Pattern</span><br><span class="line">    return &#123;</span><br><span class="line">        foo: foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery)</span><br><span class="line"></span><br><span class="line">Module.foo();</span><br></pre></td></tr></table></figure><div class="note warning">            <p>这就是模块模式，也是现代模块实现的基石</p>          </div><h1 id="CommonJS-amp-amp-Node-js-2009"><a href="#CommonJS-amp-amp-Node-js-2009" class="headerlink" title="CommonJS&amp;&amp; Node.js(2009)"></a><a href="http://www.commonjs.org/" target="_blank" rel="noopener">CommonJS</a>&amp;&amp; <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>(2009)</h1><p><code>CommonJS</code>规范，主要运行于<code>服务器端</code>，一个单独的文件就是一个模块，<code>同步加载</code>模块。<code>Node.js</code>很好的实现了该规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; module1.js</span><br><span class="line">exports.add &#x3D; function(a, b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; main.js</span><br><span class="line">var module1 &#x3D; require(&#39;.&#x2F;module1&#39;)&#x2F;&#x2F; 同步加载并执行</span><br><span class="line">console.log(module1.add(1, 2));    &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><div class="note warning">            <p>同步/阻塞式加载</p>          </div><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519222015.png" alt="image-20200520112846849"></p><h1 id="AMD-amp-amp-Require-js-2011"><a href="#AMD-amp-amp-Require-js-2011" class="headerlink" title="AMD &amp;&amp; Require.js(2011)"></a><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> &amp;&amp; <a href="https://requirejs.org/" target="_blank" rel="noopener">Require.js</a>(2011)</h1><p>AMD(Asynchronous Module Definition - 异步加载模块定义)规范，一个单独的文件就是一个模块，模块和模块的依赖可以被<code>异步加载</code>。主要运行于<code>浏览器端</code>。该规范是在RequireJs的推广过程中逐渐完善的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; moduleA.js</span><br><span class="line">define(</span><br><span class="line">[&#39;jQuery&#39;,&#39;lodash&#39;], &#x2F;&#x2F; 依赖</span><br><span class="line">function($, _) &#123;&#x2F;&#x2F; 这个回调会在所有依赖都被加载后才执行</span><br><span class="line">        var name &#x3D; &#39;weiqinl&#39;,</span><br><span class="line">        function foo() &#123;&#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            name,</span><br><span class="line">            foo</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">require([&#39;moduleA&#39;], function(a) &#123;</span><br><span class="line">    a.name &#x3D;&#x3D;&#x3D; &#39;weiqinl&#39; &#x2F;&#x2F; true</span><br><span class="line">    a.foo() &#x2F;&#x2F; 执行A模块中的foo函数</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;script src&#x3D;&quot;js&#x2F;require.js&quot; data-main&#x3D;&quot;js&#x2F;index&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="AMD-vs-CommonJS"><a href="#AMD-vs-CommonJS" class="headerlink" title="AMD vs CommonJS"></a>AMD vs CommonJS</h2><ul><li>书写风格</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Module&#x2F;1.0</span><br><span class="line">var a &#x3D; require(&quot;.&#x2F;a&quot;);  &#x2F;&#x2F; 依赖就近</span><br><span class="line">a.doSomething();</span><br><span class="line"></span><br><span class="line">var b &#x3D; require(&quot;.&#x2F;b&quot;)</span><br><span class="line">b.doSomething();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AMD recommended style</span><br><span class="line">define([&quot;a&quot;, &quot;b&quot;], function(a, b)&#123; &#x2F;&#x2F; 依赖前置</span><br><span class="line">    a.doSomething();</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>执行时机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Module&#x2F;1.0</span><br><span class="line">var a &#x3D; require(&quot;.&#x2F;a&quot;);  &#x2F;&#x2F; 执行到此时，a.js 同步下载并执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AMD with CommonJS sugar</span><br><span class="line">define([&quot;require&quot;], function(require)&#123;</span><br><span class="line">    &#x2F;&#x2F; 在这里， a.js 已经下载并且执行好了</span><br><span class="line">    var a &#x3D; require(&quot;.&#x2F;a&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>AMD的运行逻辑是：提前加载，提前执行。在Requirejs中，申明依赖模块时，会第一时间加载并执行模块内的代码，使后面的回调函数能在所需的环境中运行。</p><h1 id="CMD-amp-amp-Sea-js-2011"><a href="#CMD-amp-amp-Sea-js-2011" class="headerlink" title="CMD &amp;&amp; Sea.js(2011)"></a><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener">CMD</a> &amp;&amp; Sea.js(2011)</h1><p>CMD(Common Module Definition - 通用模块定义)规范主要是Sea.js推广中形成的，一个文件就是一个模块，可以像Node.js一般书写模块代码。主要在浏览器中运行，当然也可以在Node.js中运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; moduleA.js</span><br><span class="line">&#x2F;&#x2F; 定义模块</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var func &#x3D; function() &#123;</span><br><span class="line">        var a &#x3D; require(&#39;.&#x2F;a&#39;) &#x2F;&#x2F; 到此才会加载a模块</span><br><span class="line">        a.func()</span><br><span class="line">        </span><br><span class="line">        if(false) &#123;</span><br><span class="line">        var b &#x3D; require(&#39;.&#x2F;b&#39;) &#x2F;&#x2F; 到此才会加载b模块，此处条件不法进入，不会加载</span><br><span class="line">        b.func() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">exports.func &#x3D; func;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">&#x2F;&#x2F; 加载使用模块</span><br><span class="line">seajs.use(&#39;moduleA.js&#39;, function(ma) &#123;</span><br><span class="line">var ma &#x3D; math.func()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HTML，需要在页面中引入sea.js文件。</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;sea.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;js&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="AMD-VS-CMD"><a href="#AMD-VS-CMD" class="headerlink" title="AMD VS CMD"></a>AMD VS CMD</h2><ul><li>执行时机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AMD recommended</span><br><span class="line">define([&#39;a&#39;, &#39;b&#39;], function(a, b)&#123;</span><br><span class="line">    a.doSomething();    &#x2F;&#x2F; 依赖前置，提前执行</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CMD recommanded</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">    var a &#x3D; require(&quot;a&quot;);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    var b &#x3D; require(&quot;b&quot;);</span><br><span class="line">    b.doSomething();    &#x2F;&#x2F; 依赖就近，延迟执行</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CMD推崇依赖就近，延迟执行。在上面例子中，通过require引入的模块，只有当程序运行到此处的时候，模块才会自动加载执行。</p><h1 id="UMD-amp-amp-webpack"><a href="#UMD-amp-amp-webpack" class="headerlink" title="UMD &amp;&amp; webpack"></a>UMD &amp;&amp; webpack</h1><p>UMD(Universal Module Definition - 通用模块定义)模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用Node, AMD 或 browser globals 模式创建模块</span><br><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; define.amd) &#123;</span><br><span class="line">    &#x2F;&#x2F; AMD模式. 注册为一个匿名函数</span><br><span class="line">define([&#39;b&#39;], factory);</span><br><span class="line">    &#125; else if (typeof module &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; module.exports) &#123;</span><br><span class="line">    &#x2F;&#x2F; Node等类CommonJS的环境</span><br><span class="line">module.exports &#x3D; factory(require(&#39;b&#39;));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 浏览器全局变量 (root is window)</span><br><span class="line">root.returnExports &#x3D; factory(root.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(typeof self !&#x3D;&#x3D; &#39;undefined&#39; ? self : this, function (b) &#123;</span><br><span class="line">&#x2F;&#x2F; 以某种方式使用 b</span><br><span class="line">    &#x2F;&#x2F;返回一个值来定义模块导出。(即可以返回对象，也可以返回函数)</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ol><li>判断<code>define</code>为函数，并且是否存在<code>define.amd</code>，来判断是否为<code>AMD规范</code></li><li>判断<code>module</code>是否为一个对象，并且是否存在<code>module.exports</code>来判断是否为<code>CommonJS规范</code></li><li>如果以上两种都没有，设定为原始的代码规范</li></ol><p>这种模式，通常会在<code>webpack</code>打包的时候用到。<code>output.libraryTarget</code>将模块以哪种规范的文件输出。</p><h1 id="ES6-Module-amp-amp-ES6"><a href="#ES6-Module-amp-amp-ES6" class="headerlink" title="ES6 Module &amp;&amp; ES6"></a>ES6 Module &amp;&amp; ES6</h1><p>在ECMAScript 2015版本出来之后，确定了一种新的模块加载方式，我们称之为ES6 Module。它和前几种方式有区别和相同点。</p><ol><li>它因为是标准，所以未来很多浏览器会支持，可以很方便的在浏览器中使用。</li><li>它同时兼容在<code>node</code>环境下运行。</li><li>模块的导入导出，通过<code>import</code>和<code>export</code>来确定。</li><li>可以和<code>Commonjs</code>模块混合使用。</li><li><code>CommonJS</code>输出的是一个<strong>值的拷贝</strong>。ES6模块输出的是<strong>值的引用</strong>,加载的时候会做静态优化。</li><li><code>CommonJS</code>模块是运行时加载确定输出接口，ES6模块是编译时确定输出接口。</li></ol><p>ES6模块功能主要由两个命令构成：<code>import</code>和<code>export</code>。<code>import</code>命令用于输入其他模块提供的功能。<code>export</code>命令用于规范模块的对外接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出变量</span><br><span class="line">export var name &#x3D; &#39;weiqinl&#39;</span><br><span class="line">export var year &#x3D; &#39;2018&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出一个对象（推荐）</span><br><span class="line">var name &#x3D; &#39;weiqinl&#39;</span><br><span class="line">var year &#x3D; &#39;2018&#39;</span><br><span class="line">export &#123; name, year&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出函数或类</span><br><span class="line">export function add(a, b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; export default 命令</span><br><span class="line">export default function() &#123;</span><br><span class="line">console.log(&#39;foo&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>import导入其他模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常命令</span><br><span class="line">import &#123; name, year &#125; from &#39;.&#x2F;module.js&#39; &#x2F;&#x2F;后缀.js不能省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果遇到export default命令导出的模块</span><br><span class="line">import ed from &#39;.&#x2F;export-default.js&#39;</span><br></pre></td></tr></table></figure><h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><p>浏览器加载ES6模块，使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性<br>外链js文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>也可以内嵌在网页中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">import utils from &#39;.&#x2F;utils.js&#39;;</span><br><span class="line">&#x2F;&#x2F; other code</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>对于加载外部模块，需要注意：</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><h2 id="Node加载"><a href="#Node加载" class="headerlink" title="Node加载"></a>Node加载</h2><p>Node要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，就必须采用<code>.mjs</code>后缀名。<br>这个功能还在试验阶段。安装<code>Node V8.5.0</code>或以上版本，要用<code>--experimental-modules</code>参数才能打开该功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules my-app.mjs</span><br></pre></td></tr></table></figure><p><code>Node</code>的<code>import</code>命令只支持异步加载本地模块(<code>file:</code>协议)，不支持加载远程模块。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要描述了JavaScript的模块化历程，以史为鉴，可以知兴替。每种技术的出现都是为了解决一些痛点的，不要排斥新技术，也不要迷茫学习新技术，除非它能解决你的痛点。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/weiqinl/p/9940549.html" target="_blank" rel="noopener">JavaScript模块化CommonJS/AMD/CMD/UMD/ES6Module的区别</a></li><li><a href="https://github.com/weiqinl/demo/tree/master/js-module" target="_blank" rel="noopener">各模块化使用的例子</a></li><li><a href="https://requirejs.org/" target="_blank" rel="noopener">Require.js</a></li><li><a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">Sea.js</a></li><li><a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">UMD</a></li><li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">ES6 Module</a></li><li><a href="http://huangxuan.me/js-module-7day/#/" target="_blank" rel="noopener">JavaScript模块化七日谈</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript模块化历程&quot;&gt;&lt;a href=&quot;#JavaScript模块化历程&quot; class=&quot;headerlink&quot; title=&quot;JavaScript模块化历程&quot;&gt;&lt;/a&gt;JavaScript模块化历程&lt;/h1&gt;&lt;p&gt;到目前为止，大概分为以下几个里程碑式节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;函数块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命名空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;闭包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CommonJS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AMD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CMD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UMD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ES6Module&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yuanchangjian.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript模块化" scheme="https://yuanchangjian.github.io/tags/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>语义化版本控制规范（SemVer）</title>
    <link href="https://yuanchangjian.github.io/2020/05/19/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%A7%84%E8%8C%83%EF%BC%88SemVer%EF%BC%89/"/>
    <id>https://yuanchangjian.github.io/2020/05/19/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%A7%84%E8%8C%83%EF%BC%88SemVer%EF%BC%89/</id>
    <published>2020-05-19T10:04:53.000Z</published>
    <updated>2020-05-20T06:32:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>semver</code> 是 <a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本（Semantic Versioning）规范</a> 的一个实现，目前是由 <code>npm</code> 的团队维护，实现了版本和版本范围的解析、计算、比较。下面列举一个<code>npm</code>下<code>vue</code>的版本历史。</p><a id="more"></a><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519192502.png" alt="image-20200519181754033"></p><h1 id="版本格式"><a href="#版本格式" class="headerlink" title="版本格式"></a>版本格式</h1><ol><li>主版本号：当你做了不兼容的 API 修改。（如：V2.6.11 -&gt; V3.0.0-alpha.0）</li><li>次版本号：当你做了向下兼容的功能性新增。（如：V2.5.22 -&gt; V2.6.0）</li><li>修订号：当你做了向下兼容的问题修正。（如：V2.6.10 -&gt; V2.6.11）</li></ol><h1 id="先行版本"><a href="#先行版本" class="headerlink" title="先行版本"></a>先行版本</h1><p>先行版本表示这个版本并非稳定，可以作为发布正式版之前的版本，格式是在修订版本号后面加上一个连接号<code>（-）</code>，再加上一连串以点（.）分割的标识符，标识符可以由英文、数字和连接号（[0-9A-Za-z-]）组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.6.0-beta.1</span><br><span class="line">3.0.0-alpha.0</span><br><span class="line">1.0.0-0.3.7</span><br><span class="line">1.0.0-x.7.z.92</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以下是一些常见的先行版本号名称：</p><ul><li>alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</li><li>beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li><li>rc：（Release　Candidate)  系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</li></ul><h1 id="版本编译元数据（可选）"><a href="#版本编译元数据（可选）" class="headerlink" title="版本编译元数据（可选）"></a>版本编译元数据（可选）</h1><p>版本编译元数据可以被标注在修订版或先行版本号之后，先加上一个<code>加号</code>再加上一连串以句点分隔的标识符来修饰。当判断版本的优先层级时，版本编译元数据可被忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.0.0-alpha+001</span><br><span class="line">1.0.0+20130313144700</span><br><span class="line">1.0.0-beta+exp.sha.5114f85</span><br></pre></td></tr></table></figure><h1 id="定义依赖版本号"><a href="#定义依赖版本号" class="headerlink" title="定义依赖版本号"></a>定义依赖版本号</h1><p>在 <a href="https://npmjs.com/" target="_blank" rel="noopener">npm</a> 的依赖的规则中，还有 <code>~</code>、<code>&gt;</code>、<code>&lt;</code>、<code>=</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>-</code>、<code>||</code>、<code>x</code>、<code>X</code>、<code>*</code> 等符号；当使用 <code>npm install XX</code> 时，被安装的依赖的版本号前会默认加上 <code>^</code> 符号。</p><ul><li><code>^</code> ：表示同一主版本号中，不小于指定版本号的版本号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &#96;^2.2.1&#96; 对应主版本号为 2，不小于 &#96;2.2.1&#96; 的版本号，比如 &#96;2.2.1&#96;、&#96;2.2.2&#96;、&#96;2.3.0&#96; ,主版本号固定</span><br><span class="line">&#x2F;&#x2F; 当该依赖有最新版本时(eg:2.3.3)，npm install 会安装最新的依赖</span><br></pre></td></tr></table></figure><ul><li><code>~</code> ：表示同一主版本号和次版本号中，不小于指定版本号的版本号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;~2.2.1&#96; 对应主版本号为 2，次版本号为 2，不小于 &#96;2.2.1&#96; 的版本号，比如 &#96;2.2.1、2.2.2&#96;，主版本号和次版本号固定</span><br></pre></td></tr></table></figure><p>常用的就是上述两种情况，拿vue做个例子：</p><ul><li>项目兼容vue发布的次版本和补丁版本：”vue”: “^2.5.0”</li><li>项目只兼容vue发布的补丁版本：”vue”: “~2.5.0”（发布2.6.0不会更新）</li></ul><div class="note warning">            <p><strong>npm 中 package-lock.json 的一些坑</strong></p><p>在 npm install 后，会生成一个 package-lock.json 文件用于保存当前安装依赖的各种来源及版本号。</p><p>在 npm 5.4.2版本后，package-lock.json 的变动规则：</p><ul><li>当在 install dependency 的指定版本时，会自动更新 package-lock.json 文件中该 dependency 的 version 到指定的 version</li><li>当在 install dependency 的范围版本时，当前的 version 低于或等于 package-lock.json 文件中对应的 dependency 的 version 时，会安装 package-lock.json 中的 version；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&quot;antd&quot;: &quot;^3.6.1&quot;, &#x2F;&#x2F; eg：最新版本是 3.9.4</span><br><span class="line"></span><br><span class="line">package-lock.json</span><br><span class="line">&quot;antd&quot;: &quot;3.7.1&quot;,</span><br><span class="line"></span><br><span class="line">执行npm install 会安装 3.7.1 版本</span><br></pre></td></tr></table></figure><p>如果高于 package-lock.json 中对应的 dependency 的 version 时，会安装当前范围版本号中最高的版本，会更新 package-lock.json 文件中对应的版本号；</p><p>若版本使用<code>^</code>匹配符，想<code>临时</code>跳到某个固定版本，可以如下所示安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save antd@3.6.1</span><br></pre></td></tr></table></figure><p>若要固定版本，可以先删除<code>package-lock.json</code>，将<code>package.json</code>将antd改为<code>3.6.1</code>，不使用<code>匹配符</code>，执行<code>npm install</code></p>          </div><h1 id="npm包发布"><a href="#npm包发布" class="headerlink" title="npm包发布"></a>npm包发布</h1><p>通常我们发布一个包到npm仓库时，我们的做法是先修改 <code>package.json</code> 为某个版本，然后执行 <code>npm publish</code> 命令。手动修改版本号的做法建立在你对Semver规范特别熟悉的基础之上，否则可能会造成版本混乱。npm 考虑到了这点，它提供了相关的命令来让我们更好的遵从Semver规范：</p><ul><li>升级补丁版本号：npm version patch</li><li>升级小版本号：npm version minor</li><li>升级大版本号：npm version major</li></ul><p>当执行 <code>npm publish</code> 时，会首先将当前版本发布到 <code>npm registry</code>，然后更新 <code>dist-tags.latest</code> 的值为新版本。</p><p>当执行 <code>npm publish --tag=next</code> 时，会首先将当前版本发布到 <code>npm registry</code>，并且更新 <code>dist-tags.next</code> 的值为新版本。这里的 next 可以是任意有意义的命名（比如：v1.x、v2.x 等等）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本 2.0.0</a></li><li><a href="https://www.jianshu.com/p/a7490344044f" target="_blank" rel="noopener">semver 语义化版本规范</a></li><li><a href="https://segmentfault.com/a/1190000014405355" target="_blank" rel="noopener">Semver(语义化版本号)扫盲</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;semver&lt;/code&gt; 是 &lt;a href=&quot;http://semver.org/lang/zh-CN/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;语义化版本（Semantic Versioning）规范&lt;/a&gt; 的一个实现，目前是由 &lt;code&gt;npm&lt;/code&gt; 的团队维护，实现了版本和版本范围的解析、计算、比较。下面列举一个&lt;code&gt;npm&lt;/code&gt;下&lt;code&gt;vue&lt;/code&gt;的版本历史。&lt;/p&gt;
    
    </summary>
    
    
      <category term="版本管理" scheme="https://yuanchangjian.github.io/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="SemVer" scheme="https://yuanchangjian.github.io/tags/SemVer/"/>
    
  </entry>
  
  <entry>
    <title>BFS和DFS</title>
    <link href="https://yuanchangjian.github.io/2020/05/19/BFS%E5%92%8CDFS/"/>
    <id>https://yuanchangjian.github.io/2020/05/19/BFS%E5%92%8CDFS/</id>
    <published>2020-05-19T02:06:03.000Z</published>
    <updated>2020-05-20T06:32:27.261Z</updated>
    
    <content type="html"><![CDATA[<p>下面我们通过一个二叉树层序遍历的题目来分析一下BFS和DFS方法的区别。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="noopener">例题</a></h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><p>左边是BFS，按照层进行搜索；右边是DFS，先一路走到底，当无路可走则回溯上来，走其他路。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519101431.png" alt="image-20200519101430606"></p><h1 id="BFS（breadth-First-Search）广度优先搜索"><a href="#BFS（breadth-First-Search）广度优先搜索" class="headerlink" title="BFS（breadth First Search）广度优先搜索"></a>BFS（breadth First Search）广度优先搜索</h1><p>BFS总共有两个通用模板。</p><p>1.如果不需要确定当前遍历到了哪一层，BFS模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while queue 不空：</span><br><span class="line">    cur &#x3D; queue.pop()</span><br><span class="line">    for 节点 in cur的所有相邻节点：</span><br><span class="line">        if 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></table></figure><p>2.如果要确定当前遍历到了哪一层，BFS模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level &#x3D; 0</span><br><span class="line">while queue 不空：</span><br><span class="line">    size &#x3D; queue.size()</span><br><span class="line">    while (size --) &#123;</span><br><span class="line">        cur &#x3D; queue.pop()</span><br><span class="line">        for 节点 in cur的所有相邻节点：</span><br><span class="line">            if 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure><p>本题要求二叉树的层次遍历，所以同一层的节点应该放在一起，故使用模板二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var levelOrder &#x3D; function(root) &#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    if (!root) return result;</span><br><span class="line">    var queue &#x3D; [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    while (queue.length !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        var length &#x3D; queue.length;</span><br><span class="line">        result.push([]);</span><br><span class="line">        for (var i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            var treeNode &#x3D; queue.shift();</span><br><span class="line">            result[result.length - 1].push(treeNode.val);</span><br><span class="line">            if (treeNode.left) queue.push(treeNode.left);</span><br><span class="line">            if (treeNode.right) queue.push(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现过程如下所示，我们先将根节点放到队列中。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519110047.png" alt="image-20200519110046014"></p><p>首先拿出根节点，如果左子树/右子树不为空，就将他们放入队列中。第一遍处理完后，根节点已经从队列中拿走了，而根节点的两个孩子已放入队列中了，现在队列中就有两个节点 <code>2</code> 和 <code>5</code>。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519110134.png" alt="image-20200519110133339"></p><p>第二次处理，会将 <code>2</code> 和 <code>5</code> 这两个节点从队列中拿走，然后再将 2 和 5 的子节点放入队列中，现在队列中就有三个节点 <code>3</code>，<code>4</code>，<code>6</code>。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200519110207.png" alt="image-20200519110206085"></p><p>我们把每层遍历到的节点都放入到一个结果集中，最后返回这个结果集就可以了。</p><p>时间复杂度： O(n)<em>O</em>(<em>n</em>)<br>空间复杂度：O(n)<em>O</em>(<em>n</em>)</p><h1 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a>DFS（Deep First Search）深度优先搜索</h1><p><img src="https://pic.leetcode-cn.com/aeed09e12573ec00d83663bb4f77562e8904ac58cdb2cbe6e995f2ac33b12934-0203_1.gif" alt="0203_1.gif"></p><p> DFS 不是按照层次遍历的。为了让递归的过程中同一层的节点放到同一个列表中，在递归时要记录每个节点的深度 level。递归到新节点要把该节点放入 level 对应列表的末尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var levelOrder &#x3D; function(root) &#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    if (!root) return result;</span><br><span class="line"></span><br><span class="line">    var dfs &#x3D; function(node, level) &#123;</span><br><span class="line">        if (result.length - 1 &lt; level) &#123;</span><br><span class="line">            result.push([]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result[level - 1].push(node.val);</span><br><span class="line">        if (node.left) dfs(node.left, level + 1);</span><br><span class="line">        if (node.right) dfs(node.right, level + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root, 0);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N)<em>O</em>(<em>N</em>)<br>空间复杂度：O(h)<em>O</em>(<em>h</em>)，<code>h</code> 是树的高度</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="数据结构上的运用"><a href="#数据结构上的运用" class="headerlink" title="数据结构上的运用"></a>数据结构上的运用</h2><p>DFS用递归的形式，用到了栈结构，先进后出。</p><p>BFS选取状态用队列的形式，先进先出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>DFS的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>思想上来说这两种方法都是穷竭列举所有的情况。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>DFS暂遇到的两个场景：层序遍历和最短路径（多源BFS）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树层序遍历（leetcode）</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/" target="_blank" rel="noopener">套模板！BFS 和 DFS 都可以解决</a></p></li><li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/" target="_blank" rel="noopener">BFS 的使用场景总结：层序遍历、最短路径问题</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/24986203" target="_blank" rel="noopener">搜索思想——DFS &amp; BFS（基础基础篇）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面我们通过一个二叉树层序遍历的题目来分析一下BFS和DFS方法的区别。&lt;/p&gt;
&lt;h1 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;例题&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;给你一个二叉树，请你返回其按 &lt;strong&gt;层序遍历&lt;/strong&gt; 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;二叉树：[3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  3
 / \
9  20
  /  \
 15   7&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [9,20],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [15,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://yuanchangjian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="BFS" scheme="https://yuanchangjian.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://yuanchangjian.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客系列：（三）Typora+PicGo实现图片上传功能</title>
    <link href="https://yuanchangjian.github.io/2020/05/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89Typora-PicGo%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD/"/>
    <id>https://yuanchangjian.github.io/2020/05/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89Typora-PicGo%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD/</id>
    <published>2020-05-12T10:25:00.000Z</published>
    <updated>2020-05-20T06:32:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>编写markdown时经常会有插入图片的需求，而粘贴的图片的地址为本地地址，部署时是无法查看的。办法总比问题多，下面教大家使用Typora+PicGo+GitHub图床给markdown愉快的添加图片。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>自行下载安装如下软件：</p><ul><li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></li><li><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a></li></ul><h2 id="Github图床"><a href="#Github图床" class="headerlink" title="Github图床"></a>Github图床</h2><ul><li>新建repository，命名为<code>cloudImage</code></li><li>添加访问token，复制并保存token（只会出现一次）</li></ul><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518162329.png" alt="image-20200518162328069"></p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518162424.png" alt="image-20200518162420210"></p><p>​    <img src="https://yuanchangjian.github.io/cloudImage/images/20200518162122.png" alt="image-20200518162120925"></p><p>​    <img src="https://yuanchangjian.github.io/cloudImage/images/20200518162215.png" alt="image-20200518162213723"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置typora"><a href="#配置typora" class="headerlink" title="配置typora"></a>配置typora</h2><p>打开typora，选择左上角<code>文件</code>，选择<code>偏好设置</code>，配置成如下所示：</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518160024.png" alt="image-20200518155153969"></p><h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><h3 id="图床设置"><a href="#图床设置" class="headerlink" title="图床设置"></a>图床设置</h3><p>根据上述新建的GitHub图床进行配置（我这里在仓库内创建了一个<code>images</code>目录存储图片）。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518162932.png" alt="image-20200518162929836"></p><h3 id="开启时间戳重命名"><a href="#开启时间戳重命名" class="headerlink" title="开启时间戳重命名"></a>开启时间戳重命名</h3><p>防止GitHub重名上传失败。</p><p> <img src="https://yuanchangjian.github.io/cloudImage/images/20200518163356.png" alt="image-20200518163355105"></p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p>将本地图片放入Typora时，会出现上传地图选项，点击上传图片即可。这里我演示一下图片地址的变化：</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518164244.png" alt="image-20200518164240350"></p><p>上传后图片地址：</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200518164336.png" alt="image-20200518164334296"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;编写markdown时经常会有插入图片的需求，而粘贴的图片的地址为本地地址，部署时是无法查看的。办法总比问题多，下面教大家使用Typora+PicGo+GitHub图床给markdown愉快的添加图片。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo搭建博客系列" scheme="https://yuanchangjian.github.io/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Hexo" scheme="https://yuanchangjian.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客系列：（二）自定义样式优化主题</title>
    <link href="https://yuanchangjian.github.io/2020/05/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A2%98/"/>
    <id>https://yuanchangjian.github.io/2020/05/12/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%8C%96%E4%B8%BB%E9%A2%98/</id>
    <published>2020-05-12T05:42:08.000Z</published>
    <updated>2020-05-20T06:32:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本教程是我对Next主题的一些自定义样式修改，主要通过两种方式：修改<code>主题配置文件</code>和自定义样式。</p><a id="more"></a><h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><h3 id="隐藏文章更新日期"><a href="#隐藏文章更新日期" class="headerlink" title="隐藏文章更新日期"></a>隐藏文章更新日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at:</span><br><span class="line">    enable: false</span><br><span class="line">    another_day: true</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure><h3 id="友情链接行内布局"><a href="#友情链接行内布局" class="headerlink" title="友情链接行内布局"></a>友情链接行内布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-link</span><br><span class="line">  title: Links</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: inline</span><br></pre></td></tr></table></figure><h3 id="footer图标颜色"><a href="#footer图标颜色" class="headerlink" title="footer图标颜色"></a>footer图标颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  ...</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in Font Awesome. See: https:&#x2F;&#x2F;fontawesome.com&#x2F;icons</span><br><span class="line">    name: fa fa-heart</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#000000&quot;&#39;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h2><p>在主题目录的<code>/source/css</code>目录下新建<code>_custom.styl</code>文件。内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 文章目录显示多级标题,文章展示所有二级菜单</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;显示一级标题下的子标题</span><br><span class="line">.post-toc .nav .nav-level-1 &gt; .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;显示二级标题下的子标题</span><br><span class="line">&#x2F;*.post-toc .nav .nav-level-2 &gt; .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;&#x2F;*</span><br><span class="line">&#x2F;&#x2F;显示三级标题下的子标题</span><br><span class="line">&#x2F;*.post-toc .nav .nav-level-3 &gt; .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* 导航栏菜单右对齐</span><br><span class="line">*&#x2F;</span><br><span class="line">.menu &#123;</span><br><span class="line">  text-align: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本教程是我对Next主题的一些自定义样式修改，主要通过两种方式：修改&lt;code&gt;主题配置文件&lt;/code&gt;和自定义样式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo搭建博客系列" scheme="https://yuanchangjian.github.io/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Hexo" scheme="https://yuanchangjian.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客系列：（一）搭建属于自己的博客网站</title>
    <link href="https://yuanchangjian.github.io/2020/05/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <id>https://yuanchangjian.github.io/2020/05/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</id>
    <published>2020-05-11T12:18:48.000Z</published>
    <updated>2020-05-20T06:32:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本教程是对Hexo+NexT博客部署到GitHub Pages的总结，你可以参照这个教程搭建出基本能用的博客网站，若你有自己的想法，可以自己参考相关文档进行个性化配置。针对后续我自己博客的个性化配置，我会在这一系列教程的其他教程中一一列举出来。</p><a id="more"></a><h1 id="Hexo建站"><a href="#Hexo建站" class="headerlink" title="Hexo建站"></a>Hexo建站</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个基于<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>的静态博客框架，它使用Markdown(或其他渲染引擎)解析文章，快速且高效。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>需要先安装下列应用程序：</p><ul><li>Node.js(最新版本，我的版本是V.12.13.0)</li><li>Git</li></ul><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，文件夹目录如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a>信息。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。</p><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a>文件夹。当您新建文章时，Hexo 会根据scaffold来建立文件。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为<code>_</code>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到<code>public</code>文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a>文件夹。Hexo会根据主题来生成静态页面。</p><h1 id="NexT主题"><a href="#NexT主题" class="headerlink" title="NexT主题"></a>NexT主题</h1><p><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">NexT</a>是Hexo主题中最受欢迎的一款主题（star最多），风格简洁，确实很好看。HexT的GitHub代码仓库经常变动，主要是下列3个仓库:</p><ul><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">2014-2017版本(当前最新V5.1.4)</a></li><li><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">2018-2019(当前最新V7.8.0)</a></li><li><a href="https://github.com/next-theme/hexo-theme-next" target="_blank" rel="noopener">2020(<code>当前最新版本v8.0.0-rc.2，使用版本</code>)</a></li></ul><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为<code>站点配置文件</code>， 后者称为<code>主题配置文件</code></p><h2 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h2><p>Hexo主题安装非常简单，只需要将主题文件拷贝至站点目录<code>themes</code>目录下，将主题目录命名为<code>next</code>。</p><h2 id="启动主题"><a href="#启动主题" class="headerlink" title="启动主题"></a>启动主题</h2><p>打开<code>站点配置文件</code>， 找到<code>theme</code>字段，并将其值更改为<code>next</code>。</p><h2 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm run server</span><br></pre></td></tr></table></figure><p>使用浏览器访问<code>http://localhost:4000</code>，检查站点是否正确运行。<img src="https://yuanchangjian.github.io/cloudImage/images/20200515102636697.png" alt="image-20200515102636697"></p><p>现在，你已经成功安装并启用了 NexT 主题。下一步我们将对主题进行个性化配置。</p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>主题生效后，我们便开始配置主题的基本设置。</p><h3 id="设置站点标题"><a href="#设置站点标题" class="headerlink" title="设置站点标题"></a>设置站点标题</h3><p>编辑<code>站点配置文件</code>， 将<code>title</code>设置成你的站点标题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Ycj&#39;s Blog</span><br></pre></td></tr></table></figure><h3 id="设置站点描述"><a href="#设置站点描述" class="headerlink" title="设置站点描述"></a>设置站点描述</h3><p>编辑<code>站点配置文件</code>， 设置<code>description</code>字段为你的站点描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">description: 我是要成为海贼王的男人</span><br></pre></td></tr></table></figure><h3 id="设置作者昵称"><a href="#设置作者昵称" class="headerlink" title="设置作者昵称"></a>设置作者昵称</h3><p>编辑<code>站点配置文件</code>， 设置<code>author</code>为你的昵称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">author: Ycj</span><br></pre></td></tr></table></figure><h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>编辑<code>站点配置文件</code>， 将<code>language</code>设置成你所需要的语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><h3 id="设置外观"><a href="#设置外观" class="headerlink" title="设置外观"></a>设置外观</h3><p>Scheme 的切换通过更改<code>主题配置文件</code>，搜索<code>scheme</code>关键字。目前NexT支持四种外观，分别是：</p><ul><li>Muse</li><li>Mist</li><li>Pisces</li><li>Gemini</li></ul><p>我比较喜欢<code>Mist</code>这种风格，你可以自己都尝试一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure><h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>NexT默认菜单项如下所示，我当前使用了<code>home(首页)</code>、<code>categories(分类)</code>、<code>archives(归档)</code>、<code>tags(标签)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  # about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  # schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  # sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  # commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure><h4 id="添加「分类」页面"><a href="#添加「分类」页面" class="headerlink" title="添加「分类」页面"></a>添加「分类」页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><p>将新建的source/categories目录下的index.md增加type说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: categories</span><br><span class="line">date: 2020-05-12 10:55:35</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="添加「标签」页面"><a href="#添加「标签」页面" class="headerlink" title="添加「标签」页面"></a>添加「标签」页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>将新建的<code>source/tags</code>目录下的<code>index.md</code>增加<code>type</code>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: tags</span><br><span class="line">date: 2020-05-12 10:56:30</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="文章中添加标签和分类"><a href="#文章中添加标签和分类" class="headerlink" title="文章中添加标签和分类"></a>文章中添加标签和分类</h4><p>你可以在<code>文章</code>中的<code>Front-matter</code>中增加分类和标签，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br><span class="line">---</span><br></pre></td></tr></table></figure><div class="note danger">            <p><strong>分类方法的分歧</strong></p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>          </div><h3 id="设置侧栏"><a href="#设置侧栏" class="headerlink" title="设置侧栏"></a>设置侧栏</h3><p>可以通过修改<code>主题配置文件</code>中的<code>sidebar</code>字段来控制侧栏的行为。设置侧栏的位置，修改<code>sidebar.position</code>的值，支持的选项有：</p><ul><li>left - 靠左放置</li><li>right - 靠右放置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  #position: left</span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>编辑<code>主题配置文件</code>， 修改<code>avatar</code>下的<code>url</code>字段，url可以是站内或完整的互联网URI:</p><ul><li>完整的互联网URI</li><li>站点内的地址，放置在主题<code>source/images/</code>目录下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.gif</span><br></pre></td></tr></table></figure><h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p>安装<code>hexo-generator-feed</code>插件，它是hexo博客专门生成RSS xml文件的插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>编辑<code>站点配置文件</code>，在文件末尾添加下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># rss配置</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure><div class="note warning">            <p>RSS自动生成按钮在NexT V7.6.0版本移除，V7.6.0以下的NexT版本的博客网站普遍都有一个RSS按钮，不用担心，我们可以通过下面提到的设置社交链接展示出来。 </p>          </div><h3 id="设置社交链接"><a href="#设置社交链接" class="headerlink" title="设置社交链接"></a>设置社交链接</h3><p>编辑<code>主题配置文件</code>， 在<code>social</code>中添加社交链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;yuanchangjian || fab fa-github</span><br><span class="line">  RSS: &#x2F;atom.xml || fa fa-rss</span><br><span class="line">  # 等等</span><br></pre></td></tr></table></figure><h3 id="设置友情链接"><a href="#设置友情链接" class="headerlink" title="设置友情链接"></a>设置友情链接</h3><p>编辑<code>主题配置文件</code>，在<code>links</code>下添加你的友情链接地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  CoolShell: https:&#x2F;&#x2F;coolshell.cn&#x2F;</span><br><span class="line">  Eric: &#39;https:&#x2F;&#x2F;github.com&#x2F;lizhaoting&#39;</span><br></pre></td></tr></table></figure><h3 id="添加腾讯公益404页面"><a href="#添加腾讯公益404页面" class="headerlink" title="添加腾讯公益404页面"></a>添加腾讯公益404页面</h3><p>腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！<br>使用方法，新建<code>404.html</code>页面，放到主题的<code>source</code>目录下，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8;&quot;&#x2F;&gt;</span><br><span class="line">  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;all&quot; &#x2F;&gt;</span><br><span class="line">  &lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;index,follow&quot;&#x2F;&gt;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;style&#x2F;404style.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;plain&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.qq.com&#x2F;404&#x2F;search_children.js&quot;</span><br><span class="line">          charset&#x3D;&quot;utf-8&quot; homePageUrl&#x3D;&quot;&#x2F;&quot;</span><br><span class="line">          homePageName&#x3D;&quot;回到我的主页&quot;&gt;</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;data.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;qzone.qq.com&#x2F;gy&#x2F;404&#x2F;page.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="设置站点建立时间"><a href="#设置站点建立时间" class="headerlink" title="设置站点建立时间"></a>设置站点建立时间</h3><p>这个时间将在站点的底部显示，例如 © 2020 - 2022。 编辑<code>主题配置文件</code>，修改<code>since</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2020</span><br></pre></td></tr></table></figure><p>现在，你已经完成了主题的基本配置，页面展示如下所示：</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515110050.png" alt="image-20200515110048107"></p><hr><h2 id="集成常用的第三方服务"><a href="#集成常用的第三方服务" class="headerlink" title="集成常用的第三方服务"></a>集成常用的第三方服务</h2><h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>相较官网提供几种<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-system" target="_blank" rel="noopener">搜索服务</a>，我这里使用的是<code>Local Search</code>，提供一个页面快速文章的功能。</p><ol><li><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>站点配置文件</strong>，新增以下内容到任意位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>编辑 <strong>主题配置文件</strong>，启用本地搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li></ol><p>重启应用，效果如下：<img src="https://yuanchangjian.github.io/cloudImage/images/20200515110300.png" alt="image-20200515110258588"></p><h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>我这里使用了<a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">不蒜子统计</a>+LeanCloud实现站内的数据统计，这里提及一下，不蒜子现在版本对于首页多个文章无法统计阅读量，所以我i将不蒜子是用来统计网站访问量和用户量，LeanCloud用来统计文章的阅读量。</p><ul><li><p>不蒜子统计</p><p>编辑主题配置文件，找到<code>busuanzi_count</code>字段，修改为如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure></li></ul><p>效果图如下（统计数不对是因为开发环境如此，部署会正确展示）：<img src="https://yuanchangjian.github.io/cloudImage/images/20200515111953.png" alt="image-20200515111951296"></p><ul><li><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a></li></ul><ol><li><p>创建应用</p><p>应用名随意填写，不满意后续可更改。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515113114.png" alt="image-20200515113112829"></p></li><li><p>新建Class</p><p>为了保证我们前面对NexT主题的修改兼容，此处的新建Class名字必须为<code>Counter</code>。</p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515113917.png" alt="image-20200515113916349"></p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515113950.png" alt="image-20200515113948683"></p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515115930.png" alt="image-20200515114552823"></p></li></ol><ol start="3"><li><p>配置LeanCloud</p><p>获取<code>app_id</code>和<code>app_key</code></p><p><img src="https://yuanchangjian.github.io/cloudImage/images/20200515115919.png" alt="image-20200515115918389"></p><p>编辑主题配置文件，找到<code>leancloud_visitors</code>字段，将你的<code>app_id</code>和<code>app_key</code>填上，并修改<code>security</code>为<code>false</code>，修改为如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: ture</span><br><span class="line">  app_id: xxx # &lt;your app id&gt;</span><br><span class="line">  app_key: xxx # &lt;your app key&gt;</span><br><span class="line">  server_url: # &lt;your server url&gt;</span><br><span class="line">  security: false</span><br></pre></td></tr></table></figure></li></ol><h1 id="部署至GitHub-Pages"><a href="#部署至GitHub-Pages" class="headerlink" title="部署至GitHub Pages"></a>部署至GitHub Pages</h1><p>部署参考<a href="https://hexo.io/zh-cn/docs/github-pages" target="_blank" rel="noopener">官网部署教程</a>，这里我列出来是因为我想通过<code>&lt;GitHub 用户名&gt;.github.io</code>访问博客，但我发现<code>GitHub Pages</code>的部署分支只能为<code>master</code>，所以我修改了<code>.travis.yaml</code>文件，使我们在其他分支中（如：<code>hexo</code>）开发，而通过Travis CI工具部署至<code>master</code>分支，从而保证<code>&lt;GitHub 用户名&gt;.github.io</code>能正常访问。</p><p>如果你不需要<code>&lt;GitHub 用户名&gt;.github.io</code>如此访问，可以接受<code>&lt;GitHub 用户名&gt;.github.io/xxx</code>访问就无需更改<code>.travis.yaml</code>文件，可以跳过本小节教程，直接参考官网部署教程。</p><ol><li><p>新建一个 repository。如果你希望你的站点能通过 <code>&lt;GitHub 用户名&gt;.github.io</code> 域名访问，你的 repository 应该直接命名为 <code>&lt;GitHub 用户名&gt;.github.io</code>。</p></li><li><p>将你的 Hexo 站点文件夹推送到 repository 中。默认情况下不应该 <code>public</code> 目录将不会被推送到 repository 中，你应该检查 <code>.gitignore</code> 文件中是否包含 <code>public</code> 一行，如果没有请加上。</p></li><li><p>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</p></li><li><p>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</p></li><li><p>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/" target="_blank" rel="noopener">手动前往</a>。</p></li><li><p>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</p></li><li><p>回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存。</p></li><li><p><strong>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - hexo # build master branch only (修改点：master -&gt; hexo)</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: hexo # (修改点：master -&gt; hexo)</span><br><span class="line">  local-dir: public</span><br><span class="line">  target-branch: master # (增加项：将hexo分支编译到master分支部署)</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官方网站</a></p></li><li><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Hexo官方使用文档</a></p></li><li><p><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a></p></li><li><p><a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">Travis CI官方说明文档</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本教程是对Hexo+NexT博客部署到GitHub Pages的总结，你可以参照这个教程搭建出基本能用的博客网站，若你有自己的想法，可以自己参考相关文档进行个性化配置。针对后续我自己博客的个性化配置，我会在这一系列教程的其他教程中一一列举出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo搭建博客系列" scheme="https://yuanchangjian.github.io/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Hexo" scheme="https://yuanchangjian.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
